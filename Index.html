<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Let's anno.</title>

<script src="pdf.js"></script>
<script src="xlsx.full.min.js"></script>

<style>
  body {
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial;
    background:#f5f6fa;
    color:#222;
    text-align:center;
    padding:30px;
  }

  input, button, textarea {
    margin:10px;
    padding:10px;
    border-radius:6px;
    border:1px solid #ccc;
    font-size:16px;
  }

  button { background:#0078ff; color:#fff; cursor:pointer; border:none; }
  button:hover { background:#005fd1; }

  textarea { width:80%; max-width:800px; }

  .leftControls {
    position:absolute;
    left:80px;
    top:135px;
    display:flex;
    flex-direction:column;
    gap:15px;
    text-align:left;
  }

  #output {
    margin-top:20px;
    font-size:15px;
    text-align:left;
    display:inline-block;
    width:85%;
    background:#fff;
    border-radius:8px;
    padding:12px;
    box-shadow:0 2px 6px rgba(0,0,0,0.1);
    white-space:pre-wrap;
  }

  #debugRowZone {
    display:none;
    position:absolute;
    right:60px;
    top:260px;
    text-align:right;
  }

  #pdfContainer { margin-top:170px; }

  canvas {
    border:1px solid #ccc;
    box-shadow:0 0 5px rgba(0,0,0,0.2);
    display:block;
  }

  #debugButton {
    background:#ccc !important;
    color:#000 !important;
    padding:10px 16px;
    border-radius:6px;
    border:1px solid #aaa;
  }

  #debugButton:hover { background:#b5b5b5 !important; }

  #manualFields { display:none; }

  #autoAnnotateButton {
    margin-top:20px;
    margin-bottom:10px;
  }

  #passwordSection {
    margin: 20px auto;
    padding: 30px;
    background: #fff;
    border-radius: 8px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    max-width: 400px;
  }

  #passwordSection input[type="password"] {
    width: 200px;
  }

  #passwordError {
    color: #cc0000;
    margin-top: 10px;
    display: none;
  }

  .protected-content {
    display: none;
  }
</style>
</head>

<body>

<h1>Annomancer</h1>
<p>A little science. A little magic. A roll of the dice. Boom. You've got annos.</p>

<div id="passwordSection">
  <h3>üîê Enter Password to Continue</h3>
  <input type="password" id="passwordInput" placeholder="Enter password">
  <button id="passwordSubmit">Submit</button>
  <p id="passwordError">Incorrect password. Try again.</p>
</div>

<div id="protectedContent" class="protected-content">
<div class="leftControls">
  <label><b>Border Color:</b></label>
  <input type="color" id="borderPicker" value="#FF0000">

  <label><b>Text Box Color:</b></label>
  <input type="color" id="textPicker" value="#000080">
</div>

<div style="position:relative; width:85%; margin:auto; margin-top:10px;">
  <div style="text-align:center;">
    <input type="file" id="pdfFile" accept="application/pdf" />
  </div>
  <button id="debugButton" style="position:absolute; right:0; top:0;">Debug mode</button>
</div>

<br>

<input type="file" id="excelFile" accept=".xlsx"><br>

<button id="autoAnnotateButton">I Cast Annotate!</button><br>

<div id="debugRowZone">
  <input type="number" id="rowInput" value="2" min="2" max="100" style="width:60px;">
  <button id="stepTextButton">Step text</button>
</div>

<div id="output"></div>

<div id="manualFields">
  <input type="text" id="searchTerm" placeholder="Enter word or phrase"><br>
  <textarea id="commentText" rows="3" cols="60">This is comment box text.</textarea><br>
  <button id="searchButton">Search & Show</button>
</div>

<div id="pdfContainer"></div>
</div>

<script>
/* == Password Protection == */
const CORRECT_PASSWORD = "hellfireclub";
const AUTH_COOKIE_NAME = "annomancer_auth";

function setCookie(name, value, days) {
  const expires = new Date(Date.now() + days * 864e5).toUTCString();
  document.cookie = name + "=" + encodeURIComponent(value) + "; expires=" + expires + "; path=/";
}

function getCookie(name) {
  return document.cookie.split("; ").reduce((r, v) => {
    const parts = v.split("=");
    return parts[0] === name ? decodeURIComponent(parts[1]) : r;
  }, "");
}

function checkAuth() {
  return getCookie(AUTH_COOKIE_NAME) === "authenticated";
}

function showProtectedContent() {
  document.getElementById("passwordSection").style.display = "none";
  document.getElementById("protectedContent").style.display = "block";
}

function handlePasswordSubmit() {
  const input = document.getElementById("passwordInput");
  const error = document.getElementById("passwordError");
  
  if (input.value === CORRECT_PASSWORD) {
    setCookie(AUTH_COOKIE_NAME, "authenticated", 365);
    showProtectedContent();
  } else {
    error.style.display = "block";
    input.value = "";
    input.focus();
  }
}

// Check authentication on page load
document.addEventListener("DOMContentLoaded", function() {
  if (checkAuth()) {
    showProtectedContent();
  }
  
  document.getElementById("passwordSubmit").addEventListener("click", handlePasswordSubmit);
  document.getElementById("passwordInput").addEventListener("keypress", function(e) {
    if (e.key === "Enter") {
      handlePasswordSubmit();
    }
  });
});

/* == PDF.js worker == */
pdfjsLib.GlobalWorkerOptions.workerSrc = "pdf.worker.js";

const SNEAKY_WHITE="1.0 1.0 0.988235";
const LEFT_PAD=3, RIGHT_PAD=3, DESC=0.22, TOPOS=0.02;

const measureCanvas=document.createElement('canvas');
const mctx=measureCanvas.getContext('2d');
function setFont(px,fam){ mctx.font=px+"px "+(fam||"sans-serif"); }
function measure(t){ return mctx.measureText(t).width||0; }

/* ================================================
   ULTRASPLIT SEARCH ENGINE (Option 1)
   ================================================ */
async function extractMatches(pdfData, term){
  const pdf = await pdfjsLib.getDocument({data: pdfData}).promise;
  const out = [];
  const search = term.trim();
  if (!search) return out;

  /* split positions on spaces */
  const splitPoints = [];
  for (let i=0;i<search.length;i++){
    if (search[i] === " ") splitPoints.push(i);
  }

  /* process each page */
  for (let pageNum=1; pageNum<=pdf.numPages; pageNum++){
    const page = await pdf.getPage(pageNum);
    const text = await page.getTextContent();
    let chars = [];

    /* flatten char runs */
    for (const item of text.items){
      const str=item.str||"";
      const T=item.transform;
      for (let i=0;i<str.length;i++){
        chars.push({ ch:str[i], T, item, offset:i });
      }
    }
    if (!chars.length) continue;

    const merged = chars.map(c=>c.ch).join("");
    const mergedLower = merged.toLowerCase();

    /* literal block finder */
    function findLiteralBoxes(needle){
      const nl = needle.toLowerCase();
      let idx=0, blocks=[];

      while (true){
        let pos = mergedLower.indexOf(nl, idx);
        if (pos===-1) break;
        idx = pos+1;

        let end = pos + needle.length - 1;
        if (end >= chars.length) continue;

        let minLeft=Infinity, maxRight=-Infinity;
        let minBot=Infinity, maxTop=-Infinity;

        for (let c=pos; c<=end; c++){
          const ch = chars[c];
          const T = ch.T;
          const item = ch.item;

          const runW = item.width||0;
          const runLen = item.str.length||1;
          const charW = runW/runLen;

          const h = Math.hypot(T[2],T[3]) || Math.abs(T[3]) || 10;
          const yTop = T[5] + h*(1+TOPOS);
          const yBot = T[5] - h*DESC;

          const left = T[4] + charW*ch.offset;
          const right= left + charW;

          if(left<minLeft)minLeft=left;
          if(right>maxRight)maxRight=right;
          if(yTop>maxTop)maxTop=yTop;
          if(yBot<minBot)minBot=yBot;
        }

        minLeft -= LEFT_PAD;
        maxRight += RIGHT_PAD;

        blocks.push({
          pageNum,
          x:minLeft,
          yTop:maxTop,
          yBottom:minBot,
          w:maxRight-minLeft,
          h:maxTop-minBot
        });
      }
      return blocks;
    }

    /* literal match first */
    const literal = findLiteralBoxes(search);
    if (literal.length){
      out.push(...literal);
      continue;
    }

    /* dynamic split mode */
    let giantBox=null;

    for (const split of splitPoints){
      const leftHalf = search.slice(0,split).trim();
      const rightHalf = search.slice(split+1).trim();
      if(!leftHalf || !rightHalf) continue;

      const L = findLiteralBoxes(leftHalf);
      const R = findLiteralBoxes(rightHalf);

      if(!L.length || !R.length) continue;

      /* merge */
      let minLeft=Infinity, maxRight=-Infinity;
      let minBot=Infinity, maxTop=-Infinity;

      for(const b of [...L,...R]){
        if(b.x < minLeft) minLeft=b.x;
        if(b.x+b.w > maxRight) maxRight=b.x+b.w;
        if(b.yBottom < minBot) minBot=b.yBottom;
        if(b.yTop > maxTop) maxTop=b.yTop;
      }

      giantBox = {
        pageNum,
        x:minLeft,
        yTop:maxTop,
        yBottom:minBot,
        w:maxRight-minLeft,
        h:maxTop-minBot
      };
      break;
    }

    if(giantBox) out.push(giantBox);
  }

  return out;
}

/* everything below this point stays exactly the same */

function esc(s){ return s.replace(/\\/g,"\\\\").replace(/\(/g,"\\(").replace(/\)/g,"\\)"); }

function hexToRgbFloats(hex){
  hex=hex.replace("#","");
  const r=parseInt(hex.slice(0,2),16)/255;
  const g=parseInt(hex.slice(2,4),16)/255;
  const b=parseInt(hex.slice(4,6),16)/255;
  return `${r} ${g} ${b}`;
}

function generateAnnotBlocks(matches, commentText, borderHex, textHex){
  const comment=esc((commentText||"").trim());
  const EXP=1.5, GAP=0.5, CH=55;
  const BORDER=hexToRgbFloats(borderHex);
  const TEXT=hexToRgbFloats(textHex);

  return matches.map(m=>{
    const x1=m.x, y1=m.yBottom, x2=m.x+m.w, y2=m.yTop;
    const p=m.pageNum-1;

    let square=
`<<
/Type /Annot
/Subtype /Square
/Rect [${x1} ${y1} ${x2} ${y2}]
/T (AutoGen)
/Contents ()
/Page ${p}
/C [${BORDER}]
/BS << /W 2 >>
/Border [0 0 2]
>>`;

    if(!comment) return square;

    const cw=m.w*EXP;
    const l=x1, r=l+cw;
    const t=y1-GAP;
    const b=t-CH;

    const freeText=
`<<
/Type /Annot
/Subtype /FreeText
/Subj (Text Box)
/T (AutoGen)
/Rect [${l} ${b} ${r} ${t}]
/Contents (${comment})
/Page ${p}
/DA (${TEXT} rg /Arial 10 Tf)
/DS (font: Arial,sans-serif 10.0pt; text-align:left; color:${textHex})
/C [${SNEAKY_WHITE}]
/BC [${BORDER}]
/BS << /W 2 >>
>>`;

    return square + "\n" + freeText;

  }).join("\n");
}

async function render(pdfData,matches,borderHex){
  const container=document.getElementById("pdfContainer");
  container.innerHTML="";

  const pdf=await pdfjsLib.getDocument({data:pdfData}).promise;
  const scale=1.5;

  const r=parseInt(borderHex.slice(1,3),16);
  const g=parseInt(borderHex.slice(3,5),16);
  const b=parseInt(borderHex.slice(5,7),16);

  for(let p=1;p<=pdf.numPages;p++){
    const page=await pdf.getPage(p);
    const vp=page.getViewport({scale});
    const wrap=document.createElement("div");

    const canvas=document.createElement("canvas");
    const ctx=canvas.getContext("2d");
    canvas.width=vp.width;
    canvas.height=vp.height;

    wrap.appendChild(canvas);
    container.appendChild(wrap);

    await page.render({canvasContext:ctx,viewport:vp}).promise;

    ctx.strokeStyle=`rgba(${r},${g},${b},0.9)`;
    ctx.fillStyle=`rgba(${r},${g},${b},0.25)`;
    ctx.lineWidth=2;

    matches.filter(m=>m.pageNum===p).forEach(m=>{
      const x=m.x*scale;
      const y=vp.height-(m.yTop*scale);
      const w=m.w*scale;
      const h=m.h*scale;
      ctx.fillRect(x,y,w,h);
      ctx.strokeRect(x,y,w,h);
    });
  }
}

/* Debug mode */
document.getElementById("debugButton").onclick=()=>{
  document.getElementById("manualFields").style.display="block";
  document.getElementById("debugRowZone").style.display="block";
};

/* Manual mode */
document.getElementById("searchButton").onclick=async()=>{
  const file=document.getElementById("pdfFile").files[0];
  const term=document.getElementById("searchTerm").value;
  const comment=document.getElementById("commentText").value;
  const borderHex=document.getElementById("borderPicker").value;
  const textHex=document.getElementById("textPicker").value;
  const out=document.getElementById("output");

  if(!file){ out.textContent="Select PDF."; return; }
  if(!term){ out.textContent="Enter word."; return; }

  const reader=new FileReader();
  reader.onload=async e=>{
    const data=new Uint8Array(e.target.result);
    const matches=await extractMatches(data,term);

    await render(data,matches,borderHex);

    const annots=generateAnnotBlocks(matches,comment,borderHex,textHex);

    const fdf=
`%FDF-1.2
1 0 obj
<< /FDF << /Annots [
${annots}
] >> >>
endobj
trailer
<< /Root 1 0 R >>
%%EOF`;

    const blob=new Blob([fdf],{type:"application/vnd.fdf"});
    const url=URL.createObjectURL(blob);

    out.innerHTML=`Manual FDF.<br><a href="${url}" download="manual_generated.fdf">Download</a>`;
  };
  reader.readAsArrayBuffer(file);
};

/*
  === AUTOMATION ENGINE (UNCHANGED) ===
*/

let cumulativeAnnots=[];
let automationRunning=false;

async function runAutomation(){
  if(automationRunning) return;

  const autoBtn=document.getElementById("autoAnnotateButton");
  const out=document.getElementById("output");
  const pdfInput=document.getElementById("pdfFile");
  const excelFile=document.getElementById("excelFile").files[0];

  const pdfFile=pdfInput.files[0];
  if(!pdfFile){ out.textContent="That didn't work. Look, I'm here to cast spells, not blame. Let's just stay someone may have forgot to add a pdf."; return; }
  if(!excelFile){ out.textContent="I'm magic, but not that magic. Add a spreadsheet and try again."; return; }

  automationRunning=true;
  cumulativeAnnots=[];
  let rowNum=2;

  autoBtn.disabled=true;
  autoBtn.style.background="#cc0000";
  autoBtn.textContent="Divining Annotations√¢‚Ç¨¬¶";

  const borderHex=document.getElementById("borderPicker").value;
  const textHex=document.getElementById("textPicker").value;

  const excelArray=await excelFile.arrayBuffer();
  const wb=XLSX.read(new Uint8Array(excelArray),{type:"array"});
  const sheet=wb.Sheets[wb.SheetNames[0]];
  const rows=XLSX.utils.sheet_to_json(sheet,{header:1})||[];

  const pdfArray=await pdfFile.arrayBuffer();

  while(true){
    const idx=rowNum-1;
    const row=rows[idx]||[];

    const term=row[0];
    const comment=row[2];

    if(!term){
      break;
    }

    const matches=await extractMatches(new Uint8Array(pdfArray), term.toString());
    await render(new Uint8Array(pdfArray), matches, borderHex);

    const blocks=generateAnnotBlocks(matches, comment||"", borderHex, textHex);
    cumulativeAnnots.push(blocks);

    out.textContent=`Row ${rowNum} processed√¢‚Ç¨¬¶`;
    rowNum++;
  }

  if(cumulativeAnnots.length===0){
    out.textContent="No annotations accumulated.";

    autoBtn.disabled=false;
    autoBtn.style.background="#0078ff";
    autoBtn.textContent="I Cast Annotate!";
    document.getElementById("rowInput").value=2;
    pdfInput.value="";
    automationRunning=false;
    return;
  }

  const finalBlocks=cumulativeAnnots.join("\n");

  let pdfName=pdfFile.name.replace(/\.pdf$/i,"");
  let finalName=pdfName + " from Annomancer.fdf";

  const fdf=
`%FDF-1.2
1 0 obj
<< /FDF << /Annots [
${finalBlocks}
] >> >>
endobj
trailer
<< /Root 1 0 R >>
%%EOF`;

  const blob=new Blob([fdf],{type:"application/vnd.fdf"});
  const url=URL.createObjectURL(blob);

  out.innerHTML=
    `Your annos have been 'tated. Import this onto your pdf.<br><a href="${url}" download="${finalName}">Download your annos</a>`;

  autoBtn.style.background="green";
  autoBtn.textContent="Annos are √¢‚Ç¨‚Ñ¢tated!";

  setTimeout(()=>{
    cumulativeAnnots=[];
    automationRunning=false;

    autoBtn.disabled=false;
    autoBtn.style.background="#0078ff";
    autoBtn.textContent="I Cast Annotate!";

    document.getElementById("rowInput").value=2;
    pdfInput.value="";
  },1500);
}

document.getElementById("autoAnnotateButton").onclick=runAutomation;

document.getElementById("stepTextButton").onclick=()=>{
  let r=parseInt(document.getElementById("rowInput").value,10);
  if(isNaN(r)||r<2) r=2;
  runStepOnce(r);
};

async function runStepOnce(r){
  const out=document.getElementById("output");
  const pdfFile=document.getElementById("pdfFile").files[0];
  const excelFile=document.getElementById("excelFile").files[0];

  if(!pdfFile){ out.textContent="Something went wrong. I won't say YOU forgot the pdf. But someone sure did."; return; }
  if(!excelFile){ out.textContent="I'm not that magical. You still gotta pick a spreadsheet."; return; }

  const borderHex=document.getElementById("borderPicker").value;
  const textHex=document.getElementById("textPicker").value;

  const excelArray=await excelFile.arrayBuffer();
  const wb=XLSX.read(new Uint8Array(excelArray),{type:"array"});
  const sheet=wb.Sheets[wb.SheetNames[0]];
  const rows=XLSX.utils.sheet_to_json(sheet,{header:1})||[];

  const idx=r-1;
  const row=rows[idx]||[];

  const term=row[0];
  const comment=row[2];

  if(!term){
    out.textContent="Blank encountered.";
    return;
  }

  const pdfArray=await pdfFile.arrayBuffer();
  const matches=await extractMatches(new Uint8Array(pdfArray), term.toString());
  await render(new Uint8Array(pdfArray), matches, borderHex);

  out.textContent=`Row ${r} done. Next: ${r+1}`;
  document.getElementById("rowInput").value=r+1;
}
</script>

</body>
</html>
