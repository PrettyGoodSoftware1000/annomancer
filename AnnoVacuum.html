<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
<title>Anno-Vacuum</title>
<script src="pdf.js"></script>
<script src="pdf-lib.min.js"></script>
<script src="xlsx.full.min.js"></script>
<style>
  body {
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial;
    background: #f5f6fa;
    color: #222;
    text-align: center;
    padding: 30px;
  }
  button {
    margin: 10px;
    padding: 12px 20px;
    border-radius: 6px;
    border: none;
    font-size: 16px;
    cursor: pointer;
    color: #fff;
    background: #0078ff;
  }
  button:hover { background: #005fd1; }
  button:disabled { background: #aaa; cursor: default; }
  .custom-file-input { display: inline-block; }
  .custom-file-input input[type="file"] { display: none; }
  .custom-file-input label {
    display: inline-block;
    padding: 12px 20px;
    background: #0078ff;
    color: #fff;
    border-radius: 6px;
    cursor: pointer;
    font-size: 16px;
    margin: 10px;
  }
  .custom-file-input label:hover { background: #005fd1; }
  .file-name { margin-left: 10px; font-style: italic; color: #666; }
  #status {
    margin: 20px auto;
    max-width: 700px;
    font-size: 15px;
    text-align: left;
    background: #fff;
    border-radius: 8px;
    padding: 16px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    white-space: pre-wrap;
    display: none;
  }
  #extractBtn, #colorizeBtn { display: none; }
  #downloadSection { display: none; margin-top: 20px; }
  .version-tag {
    position: absolute;
    top: 10px;
    right: 15px;
    font-size: 11px;
    color: #999;
  }
  .back-link { display: inline-block; margin-bottom: 20px; color: #0078ff; text-decoration: none; }
  .back-link:hover { text-decoration: underline; }
</style>
</head>
<body>

<div class="version-tag">Herbert v1</div>

<a href="index.html" class="back-link">‚Üê Back to Annomancer</a>

<h1>üåÄ Anno-Vacuum</h1>
<p>Upload a color-coded PDF and extract annotations into a spreadsheet.</p>

<div class="custom-file-input">
  <label for="pdfFile">Upload a Color-Coded PDF</label>
  <input type="file" id="pdfFile" accept="application/pdf" />
  <span id="pdfFileName" class="file-name"></span>
</div>
<br>

<button id="extractBtn">Extract Annos</button>
<button id="colorizeBtn" style="background:#911EB4;">Colorize</button>

<div id="status"></div>

<div id="downloadSection">
  <a id="downloadLink" href="#">
    <button type="button" style="background:#28a745;">‚¨áÔ∏è Download Spreadsheet</button>
  </a>
</div>

<div id="colorizeDownloadSection" style="display:none; margin-top:20px;">
  <a id="colorizeDownloadLink" href="#">
    <button type="button" style="background:#911EB4;">‚¨áÔ∏è Download Colorized FDF</button>
  </a>
</div>

<script>
pdfjsLib.GlobalWorkerOptions.workerSrc = "pdf.worker.js";

/* pdf-lib globals - resolved lazily so event handlers still attach
   even if pdf-lib.min.js loads after this script block runs */
let PDFDocument, PDFName, PDFArray, PDFDict, PDFString, PDFHexString;

function ensurePdfLib() {
  if (!PDFDocument && typeof PDFLib !== 'undefined') {
    ({ PDFDocument, PDFName, PDFArray, PDFDict, PDFString, PDFHexString } = PDFLib);
  }
  if (!PDFDocument) {
    throw new Error('pdf-lib.min.js is not loaded. Make sure the file exists on the server.');
  }
}

const pdfInput = document.getElementById("pdfFile");
const extractBtn = document.getElementById("extractBtn");
const status = document.getElementById("status");
const downloadSection = document.getElementById("downloadSection");
const downloadLink = document.getElementById("downloadLink");

pdfInput.onchange = function() {
  const name = this.files[0] ? this.files[0].name : "";
  document.getElementById("pdfFileName").textContent = name;
  if (this.files[0]) {
    extractBtn.style.display = "inline-block";
    document.getElementById("colorizeBtn").style.display = "inline-block";
    downloadSection.style.display = "none";
    document.getElementById("colorizeDownloadSection").style.display = "none";
    status.style.display = "none";
  }
};

extractBtn.onclick = async function() {
  const file = pdfInput.files[0];
  if (!file) return;

  extractBtn.disabled = true;
  extractBtn.textContent = "Extracting...";
  status.style.display = "block";
  status.textContent = "Loading PDF...\n";
  downloadSection.style.display = "none";

  try {
    const arrayBuf = await file.arrayBuffer();
    const data = new Uint8Array(arrayBuf);
    const results = await extractAnnotations(data);

    if (results.length === 0) {
      status.textContent += "\nNo color-coded annotation pairs found.";
      extractBtn.disabled = false;
      extractBtn.textContent = "Extract Annos";
      return;
    }

    status.textContent += `\nFound ${results.length} annotation pair(s). Building spreadsheet...\n`;
    const xlsxBlob = buildSpreadsheet(results);
    const url = URL.createObjectURL(xlsxBlob);
    const pdfName = file.name.replace(/\.pdf$/i, "");
    downloadLink.href = url;
    downloadLink.setAttribute("download", pdfName + " extracted.xlsx");
    downloadSection.style.display = "block";
    status.textContent += "Done! Click below to download.";
  } catch (err) {
    status.textContent += "\nError: " + err.message;
    console.error(err);
  }

  extractBtn.disabled = false;
  extractBtn.textContent = "Extract Annos";
};

/* ============================================================
   CORE: Extract annotations using pdf-lib (for raw annotation
   dictionaries) + pdf.js (for the text layer under boxes).

   pdf-lib gives us reliable access to:
     - Square /C (stroke color)
     - FreeText /BC (border color) and /Contents
   pdf.js gives us the text layer to find what text is under
   each Square annotation's rect.

   Matching: Square /C color === FreeText /BC color, same page.
   ============================================================ */
async function extractAnnotations(pdfData) {
  ensurePdfLib();

  /* ‚îÄ‚îÄ Phase 1: Read raw annotation dicts with pdf-lib ‚îÄ‚îÄ */
  status.textContent += "Reading annotation objects (pdf-lib)...\n";
  const pdfLib = await PDFDocument.load(pdfData, { ignoreEncryption: true });
  const libPages = pdfLib.getPages();

  const squares = [];   /* { page, rect, colorKey, color } */
  const freeTexts = [];  /* { page, rect, colorKey, contents } */

  for (let pageIdx = 0; pageIdx < libPages.length; pageIdx++) {
    const page = libPages[pageIdx];
    const annotsRef = page.node.get(PDFName.of('Annots'));
    if (!annotsRef) continue;

    const annots = page.node.lookup(PDFName.of('Annots'));
    if (!annots || !(annots instanceof PDFArray)) continue;

    let sqCount = 0, ftCount = 0;

    for (let j = 0; j < annots.size(); j++) {
      try {
        const annotRef = annots.get(j);
        const annotDict = pdfLib.context.lookup(annotRef);
        if (!(annotDict instanceof PDFDict)) continue;

        const subtype = annotDict.get(PDFName.of('Subtype'));
        if (!subtype) continue;
        const subtypeStr = subtype.asString().replace('/', '');

        const rect = readRectArray(annotDict.get(PDFName.of('Rect')));
        if (!rect) continue;

        if (subtypeStr === 'Square') {
          const color = readColorArray(annotDict.get(PDFName.of('C')));
          squares.push({
            page: pageIdx,
            rect: rect,
            colorKey: colorKey(color),
            color: color
          });
          sqCount++;
        } else if (subtypeStr === 'FreeText') {
          /* FreeText border color is /BC, NOT /C (/C is fill = sneaky white) */
          const bc = readColorArray(annotDict.get(PDFName.of('BC')));
          const contents = readPdfString(annotDict.get(PDFName.of('Contents')));
          freeTexts.push({
            page: pageIdx,
            rect: rect,
            colorKey: colorKey(bc),
            contents: contents,
            _used: false
          });
          ftCount++;
        }
      } catch (e) {
        console.warn('Annotation ' + j + ' on page ' + (pageIdx+1) + ':', e);
      }
    }

    if (sqCount > 0 || ftCount > 0) {
      status.textContent += `  Page ${pageIdx+1}: ${sqCount} box(es), ${ftCount} text box(es)\n`;
    }
  }

  if (squares.length === 0) {
    status.textContent += "No Square annotations found.\n";
    return [];
  }

  status.textContent += `Total: ${squares.length} box(es), ${freeTexts.length} text box(es)\n`;

  /* ‚îÄ‚îÄ Phase 2: Extract text layer with pdf.js ‚îÄ‚îÄ */
  status.textContent += "Reading PDF text layer (pdf.js)...\n";
  const pdfJs = await pdfjsLib.getDocument({ data: pdfData }).promise;
  const pageTextData = {};

  const pagesNeeded = new Set(squares.map(s => s.page));

  for (const pageIdx of pagesNeeded) {
    const page = await pdfJs.getPage(pageIdx + 1); /* pdf.js is 1-indexed */
    const textContent = await page.getTextContent();
    const items = [];

    for (const item of textContent.items) {
      if (!item.str) continue;
      const T = item.transform;
      const h = Math.hypot(T[2], T[3]) || Math.abs(T[3]) || 10;
      items.push({
        str: item.str,
        x: T[4],
        y: T[5],
        w: item.width || 0,
        h: h,
        yTop: T[5] + h,
        yBot: T[5] - h * 0.22
      });
    }

    pageTextData[pageIdx] = items;
  }

  /* ‚îÄ‚îÄ Phase 3: Match Squares to text + FreeTexts ‚îÄ‚îÄ */
  status.textContent += "Matching boxes to comments...\n";
  const results = [];

  for (const sq of squares) {
    const [rx1, ry1, rx2, ry2] = sq.rect;
    const sqLeft = Math.min(rx1, rx2);
    const sqRight = Math.max(rx1, rx2);
    const sqBottom = Math.min(ry1, ry2);
    const sqTop = Math.max(ry1, ry2);

    /* Find text items that overlap this Square's rect */
    const textItems = pageTextData[sq.page] || [];
    const covered = [];

    for (const item of textItems) {
      const itemLeft = item.x;
      const itemRight = item.x + item.w;
      const itemBot = item.yBot;
      const itemTop = item.yTop;

      const PAD = 3;
      if (itemRight >= sqLeft - PAD && itemLeft <= sqRight + PAD &&
          itemTop >= sqBottom - PAD && itemBot <= sqTop + PAD) {
        covered.push(item);
      }
    }

    /* Sort by reading order: top-to-bottom, left-to-right */
    covered.sort((a, b) => {
      const dy = b.y - a.y;
      if (Math.abs(dy) > 3) return dy;
      return a.x - b.x;
    });

    const extractedText = covered.map(c => c.str).join(' ').replace(/\s+/g, ' ').trim();
    if (!extractedText) continue;

    /* Find matching FreeText: same page + same color key */
    let matchedComment = '';
    let matchedIdx = -1;

    if (sq.colorKey) {
      /* First pass: exact color match, pick closest unused */
      let bestDist = Infinity;
      for (let fi = 0; fi < freeTexts.length; fi++) {
        const ft = freeTexts[fi];
        if (ft._used || ft.page !== sq.page) continue;
        if (ft.colorKey !== sq.colorKey) continue;

        const ftRect = ft.rect;
        const ftCX = (ftRect[0] + ftRect[2]) / 2;
        const ftCY = (ftRect[1] + ftRect[3]) / 2;
        const sqCX = (sqLeft + sqRight) / 2;
        const sqCY = (sqBottom + sqTop) / 2;
        const dist = Math.hypot(ftCX - sqCX, ftCY - sqCY);

        if (dist < bestDist) {
          bestDist = dist;
          matchedComment = ft.contents;
          matchedIdx = fi;
        }
      }
    }

    /* Fallback: if no color match found, try fuzzy color + proximity */
    if (matchedIdx < 0) {
      let bestDist = Infinity;
      for (let fi = 0; fi < freeTexts.length; fi++) {
        const ft = freeTexts[fi];
        if (ft._used || ft.page !== sq.page) continue;

        const ftRect = ft.rect;
        const ftCX = (ftRect[0] + ftRect[2]) / 2;
        const ftCY = (ftRect[1] + ftRect[3]) / 2;
        const sqCX = (sqLeft + sqRight) / 2;
        const sqCY = (sqBottom + sqTop) / 2;
        const dist = Math.hypot(ftCX - sqCX, ftCY - sqCY);

        if (dist < bestDist) {
          bestDist = dist;
          matchedComment = ft.contents;
          matchedIdx = fi;
        }
      }
    }

    /* Mark the matched FreeText as used */
    if (matchedIdx >= 0) {
      freeTexts[matchedIdx]._used = true;
    }

    results.push({
      page: sq.page + 1,
      text: extractedText,
      comment: matchedComment,
      color: sq.color
    });
  }

  return results;
}

/* ‚îÄ‚îÄ Helper: Read a PDF array as [n1, n2, n3, n4] numbers ‚îÄ‚îÄ */
function readRectArray(obj) {
  if (!obj || !(obj instanceof PDFArray)) return null;
  const arr = [];
  for (let i = 0; i < obj.size(); i++) {
    const val = obj.get(i);
    arr.push(typeof val.asNumber === 'function' ? val.asNumber() : parseFloat(val.toString()));
  }
  return arr.length >= 4 ? arr : null;
}

/* ‚îÄ‚îÄ Helper: Read a PDF color array as [r, g, b] floats ‚îÄ‚îÄ */
function readColorArray(obj) {
  if (!obj || !(obj instanceof PDFArray)) return null;
  const arr = [];
  for (let i = 0; i < obj.size(); i++) {
    const val = obj.get(i);
    arr.push(typeof val.asNumber === 'function' ? val.asNumber() : parseFloat(val.toString()));
  }
  return arr.length >= 3 ? arr : null;
}

/* ‚îÄ‚îÄ Helper: Read a PDF string value ‚îÄ‚îÄ */
function readPdfString(obj) {
  if (!obj) return '';
  let s;
  if (typeof obj.asString === 'function') s = obj.asString();
  else if (obj instanceof PDFHexString) s = obj.decodeText();
  else if (obj instanceof PDFString) s = obj.asString();
  else s = obj.toString();
  /* FDF encodes line breaks as \r ‚Äî convert back to real newlines */
  return s.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
}

/* ‚îÄ‚îÄ Color key: round floats for reliable comparison ‚îÄ‚îÄ */
function colorKey(colorArray) {
  if (!colorArray || colorArray.length < 3) return '';
  return colorArray.map(v => Math.round(v * 10000) / 10000).join(',');
}

/* ============================================================
   Build XLSX: Column A = boxed text, Column C = comment
   ============================================================ */
function buildSpreadsheet(results) {
  const wb = XLSX.utils.book_new();
  const wsData = [["Text from PDF", "", "Annotation Comment"]];

  for (const r of results) {
    wsData.push([r.text, "", r.comment]);
  }

  const ws = XLSX.utils.aoa_to_sheet(wsData);

  ws["!cols"] = [
    { wch: 60 },
    { wch: 5 },
    { wch: 60 }
  ];

  XLSX.utils.book_append_sheet(wb, ws, "Extracted Annotations");
  const wbOut = XLSX.write(wb, { bookType: "xlsx", type: "array" });
  return new Blob([wbOut], { type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" });
}

/* ============================================================
   COLORIZE: Apply Annomancer-style color coding to an
   uncolored annotated PDF.

   1. Read all annotations (Square, FreeText, Line) with pdf-lib
   2. On each page, assign a unique prismatic color to each Square
   3. Match each Square to a FreeText via:
      a. Find a Line annotation that connects them (endpoints near both)
      b. Fallback: nearest FreeText to the left or right
   4. Apply the Square's color to its matched FreeText (/BC) and Line (/C)
   5. Output as FDF for download
   ============================================================ */

/* Same prismatic palette as Annomancer */
const PRISMATIC_PALETTE = [
  [0.9019, 0.0980, 0.2941],
  [0.2353, 0.7059, 0.2941],
  [0.2627, 0.3882, 0.8471],
  [0.9608, 0.5098, 0.1922],
  [0.5686, 0.1176, 0.7059],
  [0.2588, 0.8314, 0.9569],
  [0.9412, 0.1961, 0.9020],
  [0.2745, 0.6000, 0.5647],
  [0.6039, 0.3882, 0.1412],
  [0.5020, 0.0000, 0.0000],
  [0.0000, 0.0000, 0.4588],
  [0.5020, 0.5020, 0.0000],
  [0.1294, 0.5882, 0.9529],
  [1.0000, 0.3412, 0.1333],
  [0.0000, 0.5882, 0.5333],
  [0.4745, 0.3333, 0.2824],
  [0.3765, 0.4902, 0.5451],
  [0.5451, 0.7647, 0.2902],
  [1.0000, 0.5961, 0.0000],
  [0.1843, 0.3098, 0.3098]
];

document.getElementById("colorizeBtn").onclick = async function() {
  const file = pdfInput.files[0];
  if (!file) return;

  const btn = document.getElementById("colorizeBtn");
  btn.disabled = true;
  btn.textContent = "Colorizing...";
  status.style.display = "block";
  status.textContent = "Loading PDF for colorization...\n";
  document.getElementById("colorizeDownloadSection").style.display = "none";

  try {
    const arrayBuf = await file.arrayBuffer();
    const data = new Uint8Array(arrayBuf);
    await new Promise(r => setTimeout(r, 50));

    const fdfContent = await colorizeAnnotations(data);
    const blob = new Blob([fdfContent], { type: 'application/vnd.fdf' });
    const url = URL.createObjectURL(blob);
    const pdfName = file.name.replace(/\.pdf$/i, "");
    const dlLink = document.getElementById("colorizeDownloadLink");
    dlLink.href = url;
    dlLink.setAttribute("download", pdfName + " colorized.fdf");
    document.getElementById("colorizeDownloadSection").style.display = "block";
    status.textContent += "Done! Download the colorized FDF below.";
  } catch (err) {
    status.textContent += "\nError: " + err.message;
    console.error(err);
  }

  btn.disabled = false;
  btn.textContent = "Colorize";
};

async function colorizeAnnotations(pdfData) {
  ensurePdfLib();

  status.textContent += "Reading annotations...\n";
  const pdfLib2 = await PDFDocument.load(pdfData, { ignoreEncryption: true });
  const pages2 = pdfLib2.getPages();

  const pageAnnots = {};

  for (let pageIdx = 0; pageIdx < pages2.length; pageIdx++) {
    const page = pages2[pageIdx];
    const annotsRef = page.node.get(PDFName.of('Annots'));
    if (!annotsRef) continue;

    const annots = page.node.lookup(PDFName.of('Annots'));
    if (!annots || !(annots instanceof PDFArray)) continue;

    pageAnnots[pageIdx] = { squares: [], freeTexts: [], lines: [], all: [] };

    for (let j = 0; j < annots.size(); j++) {
      try {
        const annotRef = annots.get(j);
        const annotDict = pdfLib2.context.lookup(annotRef);
        if (!(annotDict instanceof PDFDict)) continue;

        const subtype = annotDict.get(PDFName.of('Subtype'));
        if (!subtype) continue;
        const subtypeStr = subtype.asString().replace('/', '');

        const rect = readRectArray(annotDict.get(PDFName.of('Rect')));
        if (!rect) continue;

        const entry = { subtype: subtypeStr, rect: rect, dict: annotDict, page: pageIdx };

        if (subtypeStr === 'Line') {
          const lineL = annotDict.get(PDFName.of('L'));
          if (lineL && lineL instanceof PDFArray) {
            entry.endpoints = [];
            for (let i = 0; i < lineL.size(); i++) {
              const val = lineL.get(i);
              entry.endpoints.push(typeof val.asNumber === 'function' ? val.asNumber() : parseFloat(val.toString()));
            }
          }
        }

        if (subtypeStr === 'FreeText') {
          entry.contents = readPdfString(annotDict.get(PDFName.of('Contents')));
        }

        pageAnnots[pageIdx].all.push(entry);
        if (subtypeStr === 'Square') pageAnnots[pageIdx].squares.push(entry);
        else if (subtypeStr === 'FreeText') pageAnnots[pageIdx].freeTexts.push(entry);
        else if (subtypeStr === 'Line') pageAnnots[pageIdx].lines.push(entry);
      } catch (e) {
        console.warn('Colorize: annot ' + j + ' page ' + (pageIdx+1) + ':', e);
      }
    }
  }

  const outputAnnots = [];

  for (const pageIdx in pageAnnots) {
    const pg = pageAnnots[pageIdx];
    const squares = pg.squares;
    const freeTexts = pg.freeTexts;
    const lines = pg.lines;

    if (squares.length === 0) {
      for (const a of pg.all) outputAnnots.push(buildAnnotOutput(a, null));
      continue;
    }

    status.textContent += `  Page ${parseInt(pageIdx)+1}: ${squares.length} box(es), ${freeTexts.length} text box(es), ${lines.length} line(s)\n`;

    const usedFreeTexts = new Set();
    const usedLines = new Set();

    for (let si = 0; si < squares.length; si++) {
      const sq = squares[si];
      const color = PRISMATIC_PALETTE[si % PRISMATIC_PALETTE.length];

      const sqLeft = Math.min(sq.rect[0], sq.rect[2]);
      const sqRight = Math.max(sq.rect[0], sq.rect[2]);
      const sqBot = Math.min(sq.rect[1], sq.rect[3]);
      const sqTop = Math.max(sq.rect[1], sq.rect[3]);
      const sqCX = (sqLeft + sqRight) / 2;
      const sqCY = (sqBot + sqTop) / 2;

      /* Find a Line connecting to this Square */
      let matchedLine = null;
      let matchedLineIdx = -1;
      let bestLineDist = Infinity;

      for (let li = 0; li < lines.length; li++) {
        if (usedLines.has(li)) continue;
        const ln = lines[li];
        if (!ln.endpoints || ln.endpoints.length < 4) continue;

        const [lx1, ly1, lx2, ly2] = ln.endpoints;
        const ep1Near = pointNearRect(lx1, ly1, sqLeft, sqBot, sqRight, sqTop, 15);
        const ep2Near = pointNearRect(lx2, ly2, sqLeft, sqBot, sqRight, sqTop, 15);

        if (ep1Near || ep2Near) {
          const dist = ep1Near ?
            Math.hypot(lx1 - sqCX, ly1 - sqCY) :
            Math.hypot(lx2 - sqCX, ly2 - sqCY);
          if (dist < bestLineDist) {
            bestLineDist = dist;
            matchedLine = ln;
            matchedLineIdx = li;
          }
        }
      }

      /* Find FreeText via Line's far endpoint */
      let matchedFreeText = null;
      let matchedFtIdx = -1;

      if (matchedLine && matchedLine.endpoints) {
        const [lx1, ly1, lx2, ly2] = matchedLine.endpoints;
        const ep1Near = pointNearRect(lx1, ly1, sqLeft, sqBot, sqRight, sqTop, 15);
        const farX = ep1Near ? lx2 : lx1;
        const farY = ep1Near ? ly2 : ly1;

        let bestFtDist = Infinity;
        for (let fi = 0; fi < freeTexts.length; fi++) {
          if (usedFreeTexts.has(fi)) continue;
          const ft = freeTexts[fi];
          const ftLeft = Math.min(ft.rect[0], ft.rect[2]);
          const ftRight = Math.max(ft.rect[0], ft.rect[2]);
          const ftBot = Math.min(ft.rect[1], ft.rect[3]);
          const ftTop = Math.max(ft.rect[1], ft.rect[3]);

          if (pointNearRect(farX, farY, ftLeft, ftBot, ftRight, ftTop, 20)) {
            const ftCX = (ftLeft + ftRight) / 2;
            const ftCY = (ftBot + ftTop) / 2;
            const dist = Math.hypot(farX - ftCX, farY - ftCY);
            if (dist < bestFtDist) {
              bestFtDist = dist;
              matchedFreeText = ft;
              matchedFtIdx = fi;
            }
          }
        }
      }

      /* Fallback: nearest FreeText to left or right */
      if (!matchedFreeText) {
        let bestDist = Infinity;
        for (let fi = 0; fi < freeTexts.length; fi++) {
          if (usedFreeTexts.has(fi)) continue;
          const ft = freeTexts[fi];
          const ftLeft = Math.min(ft.rect[0], ft.rect[2]);
          const ftRight = Math.max(ft.rect[0], ft.rect[2]);
          const ftBot = Math.min(ft.rect[1], ft.rect[3]);
          const ftTop = Math.max(ft.rect[1], ft.rect[3]);
          const ftCX = (ftLeft + ftRight) / 2;
          const ftCY = (ftBot + ftTop) / 2;

          const yOverlap = !(ftTop < sqBot - 30 || ftBot > sqTop + 30);
          const dist = Math.hypot(ftCX - sqCX, ftCY - sqCY);
          const effectiveDist = yOverlap ? dist : dist * 2;

          if (effectiveDist < bestDist) {
            bestDist = effectiveDist;
            matchedFreeText = ft;
            matchedFtIdx = fi;
          }
        }
      }

      if (matchedFtIdx >= 0) usedFreeTexts.add(matchedFtIdx);
      if (matchedLineIdx >= 0) usedLines.add(matchedLineIdx);

      outputAnnots.push(buildAnnotOutput(sq, color));
      if (matchedFreeText) outputAnnots.push(buildAnnotOutput(matchedFreeText, color));
      if (matchedLine) outputAnnots.push(buildAnnotOutput(matchedLine, color));
    }

    for (let fi = 0; fi < freeTexts.length; fi++) {
      if (!usedFreeTexts.has(fi)) outputAnnots.push(buildAnnotOutput(freeTexts[fi], null));
    }
    for (let li = 0; li < lines.length; li++) {
      if (!usedLines.has(li)) outputAnnots.push(buildAnnotOutput(lines[li], null));
    }
    for (const a of pg.all) {
      if (a.subtype !== 'Square' && a.subtype !== 'FreeText' && a.subtype !== 'Line') {
        outputAnnots.push(buildAnnotOutput(a, null));
      }
    }
  }

  status.textContent += `Colorized ${outputAnnots.length} annotation(s). Generating FDF...\n`;
  return generateColorizedFDF(outputAnnots);
}

function pointNearRect(px, py, left, bot, right, top, tol) {
  if (px < left - tol || px > right + tol || py < bot - tol || py > top + tol) return false;
  const nearLeft = Math.abs(px - left) <= tol;
  const nearRight = Math.abs(px - right) <= tol;
  const nearBot = Math.abs(py - bot) <= tol;
  const nearTop = Math.abs(py - top) <= tol;
  const inYRange = py >= bot - tol && py <= top + tol;
  const inXRange = px >= left - tol && px <= right + tol;
  return (nearLeft && inYRange) || (nearRight && inYRange) ||
         (nearBot && inXRange) || (nearTop && inXRange);
}

function buildAnnotOutput(entry, color) {
  const out = {
    subtype: entry.subtype,
    rect: entry.rect,
    page: entry.page
  };

  if (entry.contents) out.contents = entry.contents;
  else {
    const c = entry.dict.get(PDFName.of('Contents'));
    if (c) out.contents = readPdfString(c);
  }

  const t = entry.dict.get(PDFName.of('T'));
  if (t) out.title = readPdfString(t);

  const subj = entry.dict.get(PDFName.of('Subj'));
  if (subj) out.subject = readPdfString(subj);

  const da = entry.dict.get(PDFName.of('DA'));
  if (da) out.da = readPdfString(da);

  const ds = entry.dict.get(PDFName.of('DS'));
  if (ds) out.ds = readPdfString(ds);

  const bs = entry.dict.get(PDFName.of('BS'));
  if (bs && bs instanceof PDFDict) {
    const w = bs.get(PDFName.of('W'));
    if (w) out.borderWidth = typeof w.asNumber === 'function' ? w.asNumber() : parseFloat(w.toString());
  }

  if (entry.endpoints) out.endpoints = entry.endpoints;

  out.colorC = readColorArray(entry.dict.get(PDFName.of('C')));
  out.colorBC = readColorArray(entry.dict.get(PDFName.of('BC')));

  if (color) {
    if (entry.subtype === 'Square') {
      out.colorC = color;
    } else if (entry.subtype === 'FreeText') {
      out.colorBC = color;
      if (!out.colorC || (out.colorC[0] > 0.9 && out.colorC[1] > 0.9 && out.colorC[2] > 0.9)) {
        out.colorC = [1.0, 1.0, 0.988235];
      }
    } else if (entry.subtype === 'Line') {
      out.colorC = color;
    }
  }

  return out;
}

function escFDF(s) {
  if (!s) return '';
  return s
    .replace(/\\/g, "\\\\")
    .replace(/\(/g, "\\(")
    .replace(/\)/g, "\\)")
    .replace(/\r\n/g, "\\r")
    .replace(/\n/g, "\\r")
    .replace(/\r/g, "\\r")
    .replace(/[\u201C\u201D]/g, '"')
    .replace(/[\u2018\u2019]/g, "'")
    .replace(/[\u2014\u2013]/g, "-")
    .replace(/\u2026/g, "...")
    .replace(/[^\x00-\x7F]/g, "");
}

function colorStr(c) {
  if (!c || c.length < 3) return '';
  return c.map(v => Math.round(v * 1000000) / 1000000).join(' ');
}

function generateColorizedFDF(annotations) {
  const blocks = [];

  for (const a of annotations) {
    let block = `<<
/Type /Annot
/Subtype /${a.subtype}
/Rect [${a.rect.join(' ')}]
/Page ${a.page}`;

    if (a.contents) block += `\n/Contents (${escFDF(a.contents)})`;
    if (a.title) block += `\n/T (${escFDF(a.title)})`;
    if (a.colorC && a.colorC.length >= 3) block += `\n/C [${colorStr(a.colorC)}]`;
    if (a.colorBC && a.colorBC.length >= 3) block += `\n/BC [${colorStr(a.colorBC)}]`;
    if (a.borderWidth !== undefined) block += `\n/BS << /W ${a.borderWidth} >>`;
    if (a.da) block += `\n/DA (${escFDF(a.da)})`;
    if (a.ds) block += `\n/DS (${escFDF(a.ds)})`;
    if (a.subject) block += `\n/Subj (${escFDF(a.subject)})`;
    if (a.endpoints && a.endpoints.length >= 4) block += `\n/L [${a.endpoints.join(' ')}]`;

    block += '\n>>';
    blocks.push(block);
  }

  return `%FDF-1.2
1 0 obj
<< /FDF << /Annots [
${blocks.join('\n')}
] >> >>
endobj
trailer
<< /Root 1 0 R >>
%%EOF`;
}
</script>

</body>
</html>
