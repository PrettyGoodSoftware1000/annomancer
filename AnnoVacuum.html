<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
<title>Anno-Vacuum</title>
<script src="pdf.js"></script>
<script src="pdf-lib.min.js"></script>
<script src="xlsx.full.min.js"></script>
<style>
  body {
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial;
    background: #f5f6fa;
    color: #222;
    text-align: center;
    padding: 30px;
  }
  button {
    margin: 10px;
    padding: 12px 20px;
    border-radius: 6px;
    border: none;
    font-size: 16px;
    cursor: pointer;
    color: #fff;
    background: #0078ff;
  }
  button:hover { background: #005fd1; }
  button:disabled { background: #aaa; cursor: default; }
  .custom-file-input { display: inline-block; }
  .custom-file-input input[type="file"] { display: none; }
  .custom-file-input label {
    display: inline-block;
    padding: 12px 20px;
    background: #0078ff;
    color: #fff;
    border-radius: 6px;
    cursor: pointer;
    font-size: 16px;
    margin: 10px;
  }
  .custom-file-input label:hover { background: #005fd1; }
  .file-name { margin-left: 10px; font-style: italic; color: #666; }
  #status {
    margin: 20px auto;
    max-width: 700px;
    font-size: 15px;
    text-align: left;
    background: #fff;
    border-radius: 8px;
    padding: 16px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    white-space: pre-wrap;
    display: none;
  }
  #extractBtn { display: none; }
  #downloadSection { display: none; margin-top: 20px; }
  .version-tag {
    position: absolute;
    top: 10px;
    right: 15px;
    font-size: 11px;
    color: #999;
  }
  .back-link { display: inline-block; margin-bottom: 20px; color: #0078ff; text-decoration: none; }
  .back-link:hover { text-decoration: underline; }
</style>
</head>
<body>

<div class="version-tag">Herbert v1</div>

<a href="index.html" class="back-link">‚Üê Back to Annomancer</a>

<h1>üåÄ Anno-Vacuum</h1>
<p>Upload a color-coded PDF and extract annotations into a spreadsheet.</p>

<div class="custom-file-input">
  <label for="pdfFile">Upload a Color-Coded PDF</label>
  <input type="file" id="pdfFile" accept="application/pdf" />
  <span id="pdfFileName" class="file-name"></span>
</div>
<br>

<button id="extractBtn">Extract Annos</button>

<div id="status"></div>

<div id="downloadSection">
  <a id="downloadLink" href="#">
    <button type="button" style="background:#28a745;">‚¨áÔ∏è Download Spreadsheet</button>
  </a>
</div>

<script>
pdfjsLib.GlobalWorkerOptions.workerSrc = "pdf.worker.js";

const { PDFDocument, PDFName, PDFArray, PDFDict, PDFString, PDFHexString } = PDFLib;

const pdfInput = document.getElementById("pdfFile");
const extractBtn = document.getElementById("extractBtn");
const status = document.getElementById("status");
const downloadSection = document.getElementById("downloadSection");
const downloadLink = document.getElementById("downloadLink");

pdfInput.onchange = function() {
  const name = this.files[0] ? this.files[0].name : "";
  document.getElementById("pdfFileName").textContent = name;
  if (this.files[0]) {
    extractBtn.style.display = "inline-block";
    downloadSection.style.display = "none";
    status.style.display = "none";
  }
};

extractBtn.onclick = async function() {
  const file = pdfInput.files[0];
  if (!file) return;

  extractBtn.disabled = true;
  extractBtn.textContent = "Extracting...";
  status.style.display = "block";
  status.textContent = "Loading PDF...\n";
  downloadSection.style.display = "none";

  try {
    const arrayBuf = await file.arrayBuffer();
    const data = new Uint8Array(arrayBuf);
    const results = await extractAnnotations(data);

    if (results.length === 0) {
      status.textContent += "\nNo color-coded annotation pairs found.";
      extractBtn.disabled = false;
      extractBtn.textContent = "Extract Annos";
      return;
    }

    status.textContent += `\nFound ${results.length} annotation pair(s). Building spreadsheet...\n`;
    const xlsxBlob = buildSpreadsheet(results);
    const url = URL.createObjectURL(xlsxBlob);
    const pdfName = file.name.replace(/\.pdf$/i, "");
    downloadLink.href = url;
    downloadLink.setAttribute("download", pdfName + " extracted.xlsx");
    downloadSection.style.display = "block";
    status.textContent += "Done! Click below to download.";
  } catch (err) {
    status.textContent += "\nError: " + err.message;
    console.error(err);
  }

  extractBtn.disabled = false;
  extractBtn.textContent = "Extract Annos";
};

/* ============================================================
   CORE: Extract annotations using pdf-lib (for raw annotation
   dictionaries) + pdf.js (for the text layer under boxes).

   pdf-lib gives us reliable access to:
     - Square /C (stroke color)
     - FreeText /BC (border color) and /Contents
   pdf.js gives us the text layer to find what text is under
   each Square annotation's rect.

   Matching: Square /C color === FreeText /BC color, same page.
   ============================================================ */
async function extractAnnotations(pdfData) {
  /* ‚îÄ‚îÄ Phase 1: Read raw annotation dicts with pdf-lib ‚îÄ‚îÄ */
  status.textContent += "Reading annotation objects (pdf-lib)...\n";
  const pdfLib = await PDFDocument.load(pdfData, { ignoreEncryption: true });
  const libPages = pdfLib.getPages();

  const squares = [];   /* { page, rect, colorKey, color } */
  const freeTexts = [];  /* { page, rect, colorKey, contents } */

  for (let pageIdx = 0; pageIdx < libPages.length; pageIdx++) {
    const page = libPages[pageIdx];
    const annotsRef = page.node.get(PDFName.of('Annots'));
    if (!annotsRef) continue;

    const annots = page.node.lookup(PDFName.of('Annots'));
    if (!annots || !(annots instanceof PDFArray)) continue;

    let sqCount = 0, ftCount = 0;

    for (let j = 0; j < annots.size(); j++) {
      try {
        const annotRef = annots.get(j);
        const annotDict = pdfLib.context.lookup(annotRef);
        if (!(annotDict instanceof PDFDict)) continue;

        const subtype = annotDict.get(PDFName.of('Subtype'));
        if (!subtype) continue;
        const subtypeStr = subtype.asString().replace('/', '');

        const rect = readRectArray(annotDict.get(PDFName.of('Rect')));
        if (!rect) continue;

        if (subtypeStr === 'Square') {
          const color = readColorArray(annotDict.get(PDFName.of('C')));
          squares.push({
            page: pageIdx,
            rect: rect,
            colorKey: colorKey(color),
            color: color
          });
          sqCount++;
        } else if (subtypeStr === 'FreeText') {
          /* FreeText border color is /BC, NOT /C (/C is fill = sneaky white) */
          const bc = readColorArray(annotDict.get(PDFName.of('BC')));
          const contents = readPdfString(annotDict.get(PDFName.of('Contents')));
          freeTexts.push({
            page: pageIdx,
            rect: rect,
            colorKey: colorKey(bc),
            contents: contents,
            _used: false
          });
          ftCount++;
        }
      } catch (e) {
        console.warn('Annotation ' + j + ' on page ' + (pageIdx+1) + ':', e);
      }
    }

    if (sqCount > 0 || ftCount > 0) {
      status.textContent += `  Page ${pageIdx+1}: ${sqCount} box(es), ${ftCount} text box(es)\n`;
    }
  }

  if (squares.length === 0) {
    status.textContent += "No Square annotations found.\n";
    return [];
  }

  status.textContent += `Total: ${squares.length} box(es), ${freeTexts.length} text box(es)\n`;

  /* ‚îÄ‚îÄ Phase 2: Extract text layer with pdf.js ‚îÄ‚îÄ */
  status.textContent += "Reading PDF text layer (pdf.js)...\n";
  const pdfJs = await pdfjsLib.getDocument({ data: pdfData }).promise;
  const pageTextData = {};

  const pagesNeeded = new Set(squares.map(s => s.page));

  for (const pageIdx of pagesNeeded) {
    const page = await pdfJs.getPage(pageIdx + 1); /* pdf.js is 1-indexed */
    const textContent = await page.getTextContent();
    const items = [];

    for (const item of textContent.items) {
      if (!item.str) continue;
      const T = item.transform;
      const h = Math.hypot(T[2], T[3]) || Math.abs(T[3]) || 10;
      items.push({
        str: item.str,
        x: T[4],
        y: T[5],
        w: item.width || 0,
        h: h,
        yTop: T[5] + h,
        yBot: T[5] - h * 0.22
      });
    }

    pageTextData[pageIdx] = items;
  }

  /* ‚îÄ‚îÄ Phase 3: Match Squares to text + FreeTexts ‚îÄ‚îÄ */
  status.textContent += "Matching boxes to comments...\n";
  const results = [];

  for (const sq of squares) {
    const [rx1, ry1, rx2, ry2] = sq.rect;
    const sqLeft = Math.min(rx1, rx2);
    const sqRight = Math.max(rx1, rx2);
    const sqBottom = Math.min(ry1, ry2);
    const sqTop = Math.max(ry1, ry2);

    /* Find text items that overlap this Square's rect */
    const textItems = pageTextData[sq.page] || [];
    const covered = [];

    for (const item of textItems) {
      const itemLeft = item.x;
      const itemRight = item.x + item.w;
      const itemBot = item.yBot;
      const itemTop = item.yTop;

      const PAD = 3;
      if (itemRight >= sqLeft - PAD && itemLeft <= sqRight + PAD &&
          itemTop >= sqBottom - PAD && itemBot <= sqTop + PAD) {
        covered.push(item);
      }
    }

    /* Sort by reading order: top-to-bottom, left-to-right */
    covered.sort((a, b) => {
      const dy = b.y - a.y;
      if (Math.abs(dy) > 3) return dy;
      return a.x - b.x;
    });

    const extractedText = covered.map(c => c.str).join(' ').replace(/\s+/g, ' ').trim();
    if (!extractedText) continue;

    /* Find matching FreeText: same page + same color key */
    let matchedComment = '';
    let matchedIdx = -1;

    if (sq.colorKey) {
      /* First pass: exact color match, pick closest unused */
      let bestDist = Infinity;
      for (let fi = 0; fi < freeTexts.length; fi++) {
        const ft = freeTexts[fi];
        if (ft._used || ft.page !== sq.page) continue;
        if (ft.colorKey !== sq.colorKey) continue;

        const ftRect = ft.rect;
        const ftCX = (ftRect[0] + ftRect[2]) / 2;
        const ftCY = (ftRect[1] + ftRect[3]) / 2;
        const sqCX = (sqLeft + sqRight) / 2;
        const sqCY = (sqBottom + sqTop) / 2;
        const dist = Math.hypot(ftCX - sqCX, ftCY - sqCY);

        if (dist < bestDist) {
          bestDist = dist;
          matchedComment = ft.contents;
          matchedIdx = fi;
        }
      }
    }

    /* Fallback: if no color match found, try fuzzy color + proximity */
    if (matchedIdx < 0) {
      let bestDist = Infinity;
      for (let fi = 0; fi < freeTexts.length; fi++) {
        const ft = freeTexts[fi];
        if (ft._used || ft.page !== sq.page) continue;

        const ftRect = ft.rect;
        const ftCX = (ftRect[0] + ftRect[2]) / 2;
        const ftCY = (ftRect[1] + ftRect[3]) / 2;
        const sqCX = (sqLeft + sqRight) / 2;
        const sqCY = (sqBottom + sqTop) / 2;
        const dist = Math.hypot(ftCX - sqCX, ftCY - sqCY);

        if (dist < bestDist) {
          bestDist = dist;
          matchedComment = ft.contents;
          matchedIdx = fi;
        }
      }
    }

    /* Mark the matched FreeText as used */
    if (matchedIdx >= 0) {
      freeTexts[matchedIdx]._used = true;
    }

    results.push({
      page: sq.page + 1,
      text: extractedText,
      comment: matchedComment,
      color: sq.color
    });
  }

  return results;
}

/* ‚îÄ‚îÄ Helper: Read a PDF array as [n1, n2, n3, n4] numbers ‚îÄ‚îÄ */
function readRectArray(obj) {
  if (!obj || !(obj instanceof PDFArray)) return null;
  const arr = [];
  for (let i = 0; i < obj.size(); i++) {
    const val = obj.get(i);
    arr.push(typeof val.asNumber === 'function' ? val.asNumber() : parseFloat(val.toString()));
  }
  return arr.length >= 4 ? arr : null;
}

/* ‚îÄ‚îÄ Helper: Read a PDF color array as [r, g, b] floats ‚îÄ‚îÄ */
function readColorArray(obj) {
  if (!obj || !(obj instanceof PDFArray)) return null;
  const arr = [];
  for (let i = 0; i < obj.size(); i++) {
    const val = obj.get(i);
    arr.push(typeof val.asNumber === 'function' ? val.asNumber() : parseFloat(val.toString()));
  }
  return arr.length >= 3 ? arr : null;
}

/* ‚îÄ‚îÄ Helper: Read a PDF string value ‚îÄ‚îÄ */
function readPdfString(obj) {
  if (!obj) return '';
  if (typeof obj.asString === 'function') return obj.asString();
  if (obj instanceof PDFHexString) return obj.decodeText();
  if (obj instanceof PDFString) return obj.asString();
  return obj.toString();
}

/* ‚îÄ‚îÄ Color key: round floats for reliable comparison ‚îÄ‚îÄ */
function colorKey(colorArray) {
  if (!colorArray || colorArray.length < 3) return '';
  return colorArray.map(v => Math.round(v * 10000) / 10000).join(',');
}

/* ============================================================
   Build XLSX: Column A = boxed text, Column C = comment
   ============================================================ */
function buildSpreadsheet(results) {
  const wb = XLSX.utils.book_new();
  const wsData = [["Text from PDF", "", "Annotation Comment"]];

  for (const r of results) {
    wsData.push([r.text, "", r.comment]);
  }

  const ws = XLSX.utils.aoa_to_sheet(wsData);

  ws["!cols"] = [
    { wch: 60 },
    { wch: 5 },
    { wch: 60 }
  ];

  XLSX.utils.book_append_sheet(wb, ws, "Extracted Annotations");
  const wbOut = XLSX.write(wb, { bookType: "xlsx", type: "array" });
  return new Blob([wbOut], { type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" });
}
</script>

</body>
</html>
