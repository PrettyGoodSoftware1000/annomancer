<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="0" />
<title>Annomancer - Metal v46</title>

<script src="pdf.js"></script>
<script src="xlsx.full.min.js"></script>

<style>
  body {
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial;
    background:#f5f6fa;
    color:#222;
    text-align:center;
    padding:30px;
  }

  input, button, textarea {
    margin:10px;
    padding:10px;
    border-radius:6px;
    border:1px solid #ccc;
    font-size:16px;
  }

  button { background:#0078ff; color:#fff; cursor:pointer; border:none; }
  button:hover { background:#005fd1; }

  textarea { width:80%; max-width:800px; }

  .leftControls {
    position:absolute;
    left:80px;
    top:365px;
    display:flex;
    flex-direction:column;
    gap:15px;
    text-align:left;
    z-index: 9999;
    background: #f5f6fa;
    padding: 15px;
    border-radius: 8px;
  }

  .leftControls select,
  .leftControls button,
  .leftControls input {
    pointer-events: auto;
    cursor: pointer;
  }

  .version-tag {
    position: absolute;
    top: 10px;
    right: 15px;
    font-size: 11px;
    color: #999;
  }

  #output {
    margin-top:20px;
    font-size:15px;
    text-align:left;
    display:inline-block;
    width:85%;
    background:#fff;
    border-radius:8px;
    padding:12px;
    box-shadow:0 2px 6px rgba(0,0,0,0.1);
    white-space:pre-wrap;
  }

  #debugRowZone {
    display:none;
    position:absolute;
    right:60px;
    top:260px;
    text-align:right;
  }

  #pdfContainer { margin-top:170px; display:none; }

  canvas {
    border:1px solid #ccc;
    box-shadow:0 0 5px rgba(0,0,0,0.2);
    display:block;
  }

  #debugButton {
    background:#ccc !important;
    color:#000 !important;
    padding:10px 16px;
    border-radius:6px;
    border:1px solid #aaa;
  }

  #debugButton:hover { background:#b5b5b5 !important; }

  #manualFields { display:none; }

  #autoAnnotateButton {
    margin-top:20px;
    margin-bottom:10px;
  }

  #passwordSection {
    margin: 20px auto;
    padding: 30px;
    background: #fff;
    border-radius: 8px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    max-width: 400px;
  }

  #passwordSection input[type="password"] {
    width: 200px;
  }

  #passwordError {
    color: #cc0000;
    margin-top: 10px;
    display: none;
  }

  .protected-content {
    display: none;
  }

  .custom-file-input {
    display: inline-block;
  }

  .custom-file-input input[type="file"] {
    display: none;
  }

  .custom-file-input label {
    display: inline-block;
    padding: 10px 16px;
    background: #0078ff;
    color: #fff;
    border-radius: 6px;
    cursor: pointer;
    font-size: 16px;
    margin: 10px;
  }

  .custom-file-input label:hover {
    background: #005fd1;
  }

  .file-name {
    margin-left: 10px;
    font-style: italic;
    color: #666;
  }
</style>
</head>

<body>

<div class="version-tag">Metal v46</div>

<img src="masthead.png" alt="Annomancer" style="max-width: 100%; width: 768px; height: auto; margin-bottom: 10px;">
<p>A little science. A little magic. A roll of the dice. Boom. You've got annos.</p>

<div id="passwordSection">
  <h3>üîê Enter Password to Continue</h3>
  <input type="password" id="passwordInput" placeholder="Enter password">
  <button id="passwordSubmit">Submit</button>
  <p id="passwordError">Incorrect password. Try again.</p>
</div>

<div id="protectedContent" class="protected-content">
<div class="leftControls">
  <label><b>Project:</b></label>
  <div style="display: flex; gap: 8px; align-items: center;">
    <select id="projectSelect" style="padding: 8px; border-radius: 4px; border: 1px solid #ccc; font-size: 14px;">
      <option value="">Loading...</option>
    </select>
    <button id="openSpreadsheetBtn" style="padding: 8px 12px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Open Spreadsheet</button>
  </div>

  <label><b>Border Color:</b></label>
  <input type="color" id="borderPicker" value="#FF0000">

  <label><b>Text Box Color:</b></label>
  <input type="color" id="textPicker" value="#FF0001">

  <label style="display:flex; align-items:center; gap:6px; cursor:pointer; margin-top:4px;">
    <input type="checkbox" id="prismaticCheck" style="margin:0; width:16px; height:16px;">
    <b>Prismatic Color Coding</b>
  </label>
</div>

<div style="position:relative; width:85%; margin:auto; margin-top:10px;">
  <div style="text-align:center;">
    <div class="custom-file-input">
      <label for="pdfFile">Select your pdf</label>
      <input type="file" id="pdfFile" accept="application/pdf" />
      <span id="pdfFileName" class="file-name"></span>
    </div>
  </div>
  <button id="debugButton" style="position:absolute; right:0; top:0;">Debug mode</button>
  <a href="Annomover.html" style="position:absolute; right:0; top:45px;">
    <button type="button" style="background:#6c757d; color:#fff; padding:10px 16px; border-radius:6px; border:1px solid #5a6268; cursor:pointer;">Annomover</button>
  </a>
</div>

<br>

<div style="background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 15px; margin-bottom: 15px; max-width: 550px; margin-left: auto; margin-right: auto;">
  <div style="font-weight: bold; margin-bottom: 10px; color: #333; text-align: center;">üìä Spreadsheet</div>
  
  <!-- Cloud URL input - hidden by default, shown in debug mode -->
  <div id="cloudUrlSection" style="margin-bottom: 12px; display: none;">
    <input type="text" id="cloudUrl" placeholder="Paste SharePoint or Egnyte link" style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #ccc; box-sizing: border-box;">
  </div>
  
  <!-- Two button row - centered -->
  <div style="display: flex; gap: 10px; align-items: center; justify-content: center; margin-bottom: 10px;">
    <button id="downloadLatestBtn" style="padding: 10px 16px; background: #0078d4; color: white; border: none; border-radius: 4px; cursor: pointer; display: flex; align-items: center; gap: 6px;">
      ‚¨áÔ∏è Download Latest Spreadsheet
    </button>
    <span style="color: #666;">‚Üí</span>
    <button id="selectDownloadedBtn" style="padding: 10px 16px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; display: flex; align-items: center; gap: 6px;">
      üìÇ Select Downloaded File
    </button>
    <input type="file" id="excelFile" accept=".xlsx" style="display: none;">
  </div>
  
  <!-- Status -->
  <div id="spreadsheetStatus" style="font-size: 13px; color: #666; text-align: center;"></div>
</div>

<button id="autoAnnotateButton">I Cast Annotate!</button><br>

<div id="debugRowZone">
  <input type="number" id="rowInput" value="2" min="2" max="100" style="width:60px;">
  <button id="stepTextButton">Step text</button>
</div>

<div id="output"></div>

<div id="manualFields">
  <input type="text" id="searchTerm" placeholder="Enter word or phrase"><br>
  <textarea id="commentText" rows="3" cols="60">This is comment box text.</textarea><br>
  <button id="searchButton">Search & Show</button>
</div>

<div id="pdfContainer"></div>
</div>

<script>
/* == Password Protection == */
const CORRECT_PASSWORD = "hellfireclub";
const AUTH_COOKIE_NAME = "annomancer_auth";

function setCookie(name, value, days) {
  const expires = new Date(Date.now() + days * 864e5).toUTCString();
  document.cookie = name + "=" + encodeURIComponent(value) + "; expires=" + expires + "; path=/";
}

function getCookie(name) {
  return document.cookie.split("; ").reduce((r, v) => {
    const parts = v.split("=");
    return parts[0] === name ? decodeURIComponent(parts[1]) : r;
  }, "");
}

function checkAuth() {
  return getCookie(AUTH_COOKIE_NAME) === "authenticated";
}

function showProtectedContent() {
  document.getElementById("passwordSection").style.display = "none";
  document.getElementById("protectedContent").style.display = "block";
}

function handlePasswordSubmit() {
  const input = document.getElementById("passwordInput");
  const error = document.getElementById("passwordError");
  
  if (input.value === CORRECT_PASSWORD) {
    setCookie(AUTH_COOKIE_NAME, "authenticated", 365);
    showProtectedContent();
  } else {
    error.style.display = "block";
    input.value = "";
    input.focus();
  }
}

// Check authentication on page load
document.addEventListener("DOMContentLoaded", function() {
  if (checkAuth()) {
    showProtectedContent();
  }
  
  document.getElementById("passwordSubmit").addEventListener("click", handlePasswordSubmit);
  document.getElementById("passwordInput").addEventListener("keypress", function(e) {
    if (e.key === "Enter") {
      handlePasswordSubmit();
    }
  });
});

/* == PDF.js worker == */
pdfjsLib.GlobalWorkerOptions.workerSrc = "pdf.worker.js";

const SNEAKY_WHITE="1.0 1.0 0.988235";
const LEFT_PAD=3, RIGHT_PAD=3, DESC=0.22, TOPOS=0.02;

const measureCanvas=document.createElement('canvas');
const mctx=measureCanvas.getContext('2d');
function setFont(px,fam){ mctx.font=px+"px "+(fam||"sans-serif"); }
function measure(t){ return mctx.measureText(t).width||0; }

/* ================================================
   METAL v45 - GREEDY SEQUENTIAL SEARCH ENGINE
   Supports up to 600 words with up to 12 line breaks
   Position-aware: segments must be sequential in PDF
   Strict proximity: max 4x line height gap, max 25 lines total
   Gap validation: only whitespace allowed between segments
   Multiple matches: finds ALL occurrences on each page
   Column A: line breaks stripped for searching
   Column C: line breaks preserved in FDF comments
   Column E: Full/Shortened claim logic with fallback
     - Full claim found ‚Üí process, skip subsequent shortened
     - Full claim NOT found ‚Üí try next shortened as fallback
     - Empty ‚Üí process normally, reset skip state
   Abbreviation mode: If A1="Abbreviation", require word boundaries
   Cloud: Projects loaded from SheetsDropdown.txt
   ================================================ */
async function extractMatches(pdfData, term, abbreviationMode = false){
  const pdf = await pdfjsLib.getDocument({data: pdfData}).promise;
  const out = [];
  const search = term.trim();
  if (!search) return out;

  const MAX_SEGMENTS = 13; /* 12 line breaks = 13 segments max */
  
  /* Characters that count as word boundaries (whitespace or punctuation) */
  const WORD_BOUNDARY_REGEX = /[\s\.,;:!?\-‚Äì‚Äî\(\)\[\]{}'"\/\\<>@#$%^&*+=|~`]/;
  
  /* Check if a character is a word boundary */
  function isWordBoundary(char) {
    if (!char) return true; /* Start/end of string counts as boundary */
    return WORD_BOUNDARY_REGEX.test(char);
  }

  /* process each page */
  for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
    const page = await pdf.getPage(pageNum);
    const vp = page.getViewport({scale:1});
    const pgW = vp.width; /* actual page width in points */
    const text = await page.getTextContent();
    let chars = [];

    const pgH = vp.height; /* actual page height in points */

    /* Detect content boundaries (margins) on this page */
    let contentLeft = Infinity, contentRight = -Infinity;
    let contentTop = -Infinity, contentBottom = Infinity;
    for (const item of text.items) {
      if (!item.str || !item.str.trim()) continue;
      const T = item.transform;
      const iw = item.width || 0;
      const h = Math.hypot(T[2], T[3]) || Math.abs(T[3]) || 10;
      const left = T[4];
      const right = T[4] + iw;
      const yTop = T[5] + h;
      const yBot = T[5] - h * 0.22;
      if (left < contentLeft) contentLeft = left;
      if (right > contentRight) contentRight = right;
      if (yTop > contentTop) contentTop = yTop;
      if (yBot < contentBottom) contentBottom = yBot;
    }
    /* Fallback if no text found */
    if (contentLeft === Infinity) contentLeft = 36;
    if (contentRight === -Infinity) contentRight = pgW - 36;
    if (contentTop === -Infinity) contentTop = pgH - 36;
    if (contentBottom === Infinity) contentBottom = 36;

    /* flatten char runs */
    for (const item of text.items) {
      const str = item.str || "";
      const T = item.transform;
      for (let i = 0; i < str.length; i++) {
        chars.push({ ch: str[i], T, item, offset: i });
      }
    }
    if (!chars.length) continue;

    const merged = chars.map(c => c.ch).join("");
    const mergedLower = merged.toLowerCase();

    /* literal block finder - returns box AND start/end position in merged text */
    function findLiteralBox(needle, startFrom = 0) {
      if (!needle) return null;
      const nl = needle.toLowerCase();

      let pos = startFrom;
      
      /* Keep searching until we find a valid match or run out of text */
      while (true) {
        pos = mergedLower.indexOf(nl, pos);
        if (pos === -1) return null;

        let end = pos + needle.length - 1;
        if (end >= chars.length) return null;
        
        /* Abbreviation mode: check word boundaries */
        if (abbreviationMode) {
          const charBefore = pos > 0 ? merged[pos - 1] : null;
          const charAfter = end + 1 < merged.length ? merged[end + 1] : null;
          
          /* Must have word boundary before and after */
          if (!isWordBoundary(charBefore) || !isWordBoundary(charAfter)) {
            /* Not a valid word boundary match, keep searching */
            pos++;
            continue;
          }
        }

        let minLeft = Infinity, maxRight = -Infinity;
        let minBot = Infinity, maxTop = -Infinity;

        for (let c = pos; c <= end; c++) {
          const ch = chars[c];
          const T = ch.T;
          const item = ch.item;

          const runW = item.width || 0;
          const runLen = item.str.length || 1;
          const charW = runW / runLen;

          const h = Math.hypot(T[2], T[3]) || Math.abs(T[3]) || 10;
          const yTop = T[5] + h * (1 + TOPOS);
          const yBot = T[5] - h * DESC;

          const left = T[4] + charW * ch.offset;
          const right = left + charW;

          if (left < minLeft) minLeft = left;
          if (right > maxRight) maxRight = right;
          if (yTop > maxTop) maxTop = yTop;
          if (yBot < minBot) minBot = yBot;
        }

        minLeft -= LEFT_PAD;
        maxRight += RIGHT_PAD;

        return {
          box: {
            pageNum,
            pageWidth: pgW,
            pageHeight: pgH,
            marginLeft: contentLeft,
            marginRight: contentRight,
            contentTop: contentTop,
            contentBottom: contentBottom,
            x: minLeft,
            yTop: maxTop,
            yBottom: minBot,
            w: maxRight - minLeft,
            h: maxTop - minBot
          },
          startPos: pos,  /* position where this match starts */
          endPos: end + 1 /* position to start next search from */
        };
      }
    }

    /* Check if boxes are within reasonable proximity of each other */
    function boxesAreProximate(boxes) {
      if (boxes.length <= 1) return true;
      
      /* Calculate average box height as baseline */
      let totalHeight = 0;
      for (const b of boxes) {
        totalHeight += b.h;
      }
      const avgHeight = totalHeight / boxes.length;
      
      /* STRICT LIMITS:
         - Vertical gap: max 4x line height (allows ~3 blank lines between segments)
         - Horizontal: boxes must overlap horizontally OR be within reasonable reading flow
         - Total height: merged box can't be more than 25x average line height (~12 real line breaks)
      */
      const maxVerticalGap = avgHeight * 4;
      const maxTotalHeight = avgHeight * 25;
      
      /* Sort boxes by vertical position (top to bottom in PDF coords) */
      const sorted = [...boxes].sort((a, b) => b.yTop - a.yTop);
      
      /* Check total vertical span */
      const topMost = sorted[0].yTop;
      const bottomMost = sorted[sorted.length - 1].yBottom;
      const totalSpan = topMost - bottomMost;
      
      if (totalSpan > maxTotalHeight) {
        return false; /* Merged box would be way too tall */
      }
      
      /* Check gap between each consecutive pair */
      for (let i = 0; i < sorted.length - 1; i++) {
        const upper = sorted[i];
        const lower = sorted[i + 1];
        
        /* Vertical gap check */
        const vGap = upper.yBottom - lower.yTop;
        if (vGap > maxVerticalGap) {
          return false; /* Too much vertical space between segments */
        }
        
        /* Horizontal overlap/proximity check for multi-column detection */
        /* Boxes should either overlap horizontally or be close enough for text flow */
        const upperLeft = upper.x;
        const upperRight = upper.x + upper.w;
        const lowerLeft = lower.x;
        const lowerRight = lower.x + lower.w;
        
        /* Check if boxes overlap horizontally */
        const horizOverlap = !(upperRight < lowerLeft || lowerRight < upperLeft);
        
        /* If no horizontal overlap, check if they're reasonably close */
        if (!horizOverlap) {
          const horizGap = Math.min(
            Math.abs(upperRight - lowerLeft),
            Math.abs(lowerRight - upperLeft)
          );
          /* Allow horizontal gap up to ~half a page width (for text wrap) */
          const pageWidth = 612; /* Standard letter width in points */
          if (horizGap > pageWidth * 0.6) {
            return false; /* Boxes are in different columns or areas */
          }
        }
      }
      return true;
    }

    /* Check if text between two positions is only whitespace */
    function isOnlyWhitespace(startPos, endPos) {
      if (startPos >= endPos) return true;
      const between = merged.substring(startPos, endPos);
      return /^\s*$/.test(between);
    }

    /* Greedy sequential: find longest match from current position, then continue */
    /* Returns { segments: [...boxes], endPos: number, firstMatchPos: number } or { firstMatchPos: number } if partial match, or null if no match at all */
    function findGreedySegments(searchText, startFrom = 0) {
      const segments = [];
      const words = searchText.split(/\s+/);
      let wordIndex = 0;
      let searchPos = startFrom; /* Position in merged PDF text - ensures sequential matches */
      let lastEndPos = startFrom; /* Track where last segment ended */
      let firstMatchPos = -1; /* Track where first segment started */

      while (wordIndex < words.length && segments.length < MAX_SEGMENTS) {
        let found = false;

        /* Try from all remaining words down to single word */
        for (let endIdx = words.length; endIdx > wordIndex; endIdx--) {
          const candidate = words.slice(wordIndex, endIdx).join(" ");
          const result = findLiteralBox(candidate, searchPos);

          if (result) {
            /* CRITICAL: Check that there's no extra text between segments */
            /* Text between lastEndPos and result.startPos should be whitespace only */
            if (segments.length > 0 && !isOnlyWhitespace(lastEndPos, result.startPos)) {
              /* There's extra text between segments - try a smaller match */
              continue;
            }

            /* Track where first match started */
            if (firstMatchPos === -1) {
              firstMatchPos = result.startPos;
            }

            segments.push(result.box);
            lastEndPos = result.endPos; /* Track where this segment ended */
            searchPos = result.endPos; /* Next search starts after this match */
            wordIndex = endIdx; /* Move past matched words */
            found = true;
            break;
          }
        }

        /* If even a single word isn't found at this position, fail */
        if (!found) {
          /* Return where we started so caller can try from next position */
          if (firstMatchPos !== -1) {
            return { segments: null, firstMatchPos };
          }
          return null; /* No match found at all from this position */
        }
      }

      /* Only return segments if ALL words were matched */
      if (wordIndex < words.length) {
        return { segments: null, firstMatchPos };
      }

      return { segments, endPos: lastEndPos, firstMatchPos };
    }

    /* Find ALL literal matches on this page */
    let literalSearchPos = 0;
    let foundLiteral = false;
    
    while (true) {
      const literalResult = findLiteralBox(search, literalSearchPos);
      if (!literalResult) break;
      
      out.push(literalResult.box);
      foundLiteral = true;
      literalSearchPos = literalResult.endPos;
    }
    
    /* If we found literal matches, move to next page */
    if (foundLiteral) continue;

    /* No literal matches - try to find ALL greedy sequential matches on this page */
    let greedySearchPos = 0;
    
    while (true) {
      const greedyResult = findGreedySegments(search, greedySearchPos);
      
      /* No match found at all from this position */
      if (!greedyResult) break;
      
      /* Partial match - first word found but couldn't complete */
      /* Try again from after the first match position */
      if (!greedyResult.segments) {
        greedySearchPos = greedyResult.firstMatchPos + 1;
        continue;
      }
      
      const segments = greedyResult.segments;
      
      /* Proximity check: reject if boxes are too far apart */
      if (!boxesAreProximate(segments)) {
        /* Skip this match but keep searching after it */
        greedySearchPos = greedyResult.endPos;
        continue;
      }

      /* Merge all segment boxes into one */
      let minLeft = Infinity, maxRight = -Infinity;
      let minBot = Infinity, maxTop = -Infinity;

      for (const b of segments) {
        if (b.x < minLeft) minLeft = b.x;
        if (b.x + b.w > maxRight) maxRight = b.x + b.w;
        if (b.yBottom < minBot) minBot = b.yBottom;
        if (b.yTop > maxTop) maxTop = b.yTop;
      }

      out.push({
        pageNum,
        pageWidth: pgW,
        pageHeight: pgH,
        marginLeft: contentLeft,
        marginRight: contentRight,
        contentTop: contentTop,
        contentBottom: contentBottom,
        x: minLeft,
        yTop: maxTop,
        yBottom: minBot,
        w: maxRight - minLeft,
        h: maxTop - minBot
      });
      
      /* Continue searching after this match */
      greedySearchPos = greedyResult.endPos;
    }
  }

  return out;
}

/* everything below this point stays exactly the same */

function esc(s){ 
  return s
    .replace(/\\/g,"\\\\")
    .replace(/\(/g,"\\(")
    .replace(/\)/g,"\\)")
    .replace(/[\r\n]+/g," ")      // Replace line breaks with space
    .replace(/[""]/g,'"')          // Smart quotes ‚Üí straight quotes
    .replace(/['']/g,"'")          // Smart apostrophes ‚Üí straight
    .replace(/[‚Äî‚Äì]/g,"-")          // Em/en dash ‚Üí hyphen
    .replace(/‚Ä¶/g,"...")           // Ellipsis ‚Üí three dots
    .replace(/[^\x00-\x7F]/g,"");  // Remove any remaining non-ASCII
}

/* Escape for comments - preserves line breaks for FDF */
function escComment(s){ 
  return s
    .replace(/\\/g,"\\\\")
    .replace(/\(/g,"\\(")
    .replace(/\)/g,"\\)")
    .replace(/\r\n/g,"\\r")        // Windows line breaks ‚Üí FDF line break
    .replace(/\n/g,"\\r")          // Unix line breaks ‚Üí FDF line break
    .replace(/\r/g,"\\r")          // Mac line breaks ‚Üí FDF line break
    .replace(/[""]/g,'"')          // Smart quotes ‚Üí straight quotes
    .replace(/['']/g,"'")          // Smart apostrophes ‚Üí straight
    .replace(/[‚Äî‚Äì]/g,"-")          // Em/en dash ‚Üí hyphen
    .replace(/‚Ä¶/g,"...")           // Ellipsis ‚Üí three dots
    .replace(/[^\x00-\x7F]/g,"");  // Remove any remaining non-ASCII
}

/* Strip line breaks from search terms */
function stripLineBreaks(s){
  return s.replace(/[\r\n]+/g," ").replace(/\s+/g," ").trim();
}

function hexToRgbFloats(hex){
  hex=hex.replace("#","");
  const r=parseInt(hex.slice(0,2),16)/255;
  const g=parseInt(hex.slice(2,4),16)/255;
  const b=parseInt(hex.slice(4,6),16)/255;
  return `${r} ${g} ${b}`;
}

/* Prismatic color palette: 20 distinct colors visible on white */
const PRISMATIC_PALETTE=[
  "#E6194B","#3CB44B","#4363D8","#F58231","#911EB4",
  "#42D4F4","#F032E6","#469990","#9A6324","#800000",
  "#000075","#808000","#2196F3","#FF5722","#009688",
  "#795548","#607D8B","#8BC34A","#FF9800","#2F4F4F"
];

/* Resolve text box overlaps with previously placed boxes.
   Shifts box downward (LEFT/RIGHT) or rightward (TOP/BOTTOM) until clear. */
function resolveBoxOverlap(l,b,r,t,side,pageBoxes){
  const GAP=6;
  for(let iter=0;iter<30;iter++){
    let shifted=false;
    for(const box of pageBoxes){
      if(l<box.r+GAP && r>box.l-GAP && b<box.t+GAP && t>box.b-GAP){
        if(side==="LEFT"||side==="RIGHT"){
          /* Shift down in PDF coords (decrease y) */
          const delta=t-(box.b-GAP);
          t-=delta; b-=delta;
        } else {
          /* Shift right */
          const delta=(box.r+GAP)-l;
          l+=delta; r+=delta;
        }
        shifted=true;
        break;
      }
    }
    if(!shifted) break;
  }
  return {l,b,r,t};
}

/* Create an FDF Line annotation between two points */
function makeLineAnnot(lx1,ly1,lx2,ly2,page,colorFloats){
  const mnX=Math.min(lx1,lx2), mxX=Math.max(lx1,lx2);
  const mnY=Math.min(ly1,ly2), mxY=Math.max(ly1,ly2);
  return `<<
/Type /Annot
/Subtype /Line
/Rect [${mnX-1} ${mnY-1} ${mxX+1} ${mxY+1}]
/L [${lx1} ${ly1} ${lx2} ${ly2}]
/Page ${page}
/C [${colorFloats}]
/BS << /W 1 >>
/T (AutoGen)
/Contents ()
>>`;
}

function generateAnnotBlocks(matches, commentText, borderHex, textHex, placedBoxes, prismaticMode, pageColorCounters){
  placedBoxes=placedBoxes||{};
  pageColorCounters=pageColorCounters||{};
  const rawComment=(commentText||"").trim();
  const comment=escComment(rawComment);
  const BORDER_DEF=hexToRgbFloats(borderHex);
  const TEXT_DEF=hexToRgbFloats(textHex);
  const TEXT_RED="1 0 0"; /* red for prismatic text */

  console.log("[Annomancer-FB] generateAnnotBlocks called, matches="+matches.length+", comment length="+rawComment.length+", prismatic="+!!prismaticMode);

  return matches.map((m,idx)=>{
    const x1=m.x, y1=m.yBottom, x2=m.x+m.w, y2=m.yTop;
    const p=m.pageNum-1;
    const pageNum=m.pageNum;

    /* Use actual page dimensions from match data, fall back to US Letter */
    const PW=m.pageWidth||612;
    const PH=m.pageHeight||792;

    /* === Prismatic color selection === */
    let BORDER, TEXT_C, textHexForDS;
    if(prismaticMode){
      if(!pageColorCounters[pageNum]) pageColorCounters[pageNum]=0;
      const ci=pageColorCounters[pageNum]%PRISMATIC_PALETTE.length;
      pageColorCounters[pageNum]++;
      const pHex=PRISMATIC_PALETTE[ci];
      BORDER=hexToRgbFloats(pHex);
      TEXT_C=TEXT_RED;
      textHexForDS="#FF0000";
    } else {
      BORDER=BORDER_DEF;
      TEXT_C=TEXT_DEF;
      textHexForDS=textHex;
    }

    let square=
`<<
/Type /Annot
/Subtype /Square
/Rect [${x1} ${y1} ${x2} ${y2}]
/T (AutoGen)
/Contents ()
/Page ${p}
/C [${BORDER}]
/BS << /W 2 >>
/Border [0 0 2]
>>`;

    if(!comment) return square;

    /* === Dynamic text box sizing using canvas measurement === */
    const LINE_H=16, PAD_H=16, PAD_V=14;
    const MAX_BOX_W=240, MIN_BOX_W=60, MIN_BOX_H=38;

    setFont(10,"Arial,sans-serif");
    const textLines=rawComment.split('\n');
    let maxLineW=0, totalTextW=0;
    for(const line of textLines){
      const w=measure(line);
      totalTextW+=w;
      if(w>maxLineW) maxLineW=w;
    }
    maxLineW*=1.4; totalTextW*=1.4;

    let boxW, boxH;
    if(maxLineW+PAD_H*2<=MAX_BOX_W && textLines.length<=3){
      boxW=Math.max(MIN_BOX_W, maxLineW+PAD_H*2);
      boxH=textLines.length*LINE_H+PAD_V*2;
    } else {
      boxW=Math.min(MAX_BOX_W, Math.max(MIN_BOX_W, maxLineW+PAD_H*2));
      const innerW=boxW-PAD_H*2;
      let totalLines=0;
      for(const line of textLines){
        totalLines+=Math.max(1, Math.ceil(measure(line)*1.4/innerW));
      }
      boxH=totalLines*LINE_H+PAD_V*2;
    }
    boxH+=LINE_H;
    boxW=Math.max(MIN_BOX_W, boxW);
    boxH=Math.max(MIN_BOX_H, boxH);

    /* === Decide placement direction === */
    const mL=m.marginLeft||36;
    const mR=m.marginRight||(PW-36);
    const cTop=m.contentTop||(PH-36);
    const cBot=m.contentBottom||36;
    const contentHeight=cTop-cBot;
    const wordCenter=(x1+x2)/2;
    const MARGIN_GAP=4, MIN_VERT_MARGIN=50;

    const topMarginSize=PH-cTop;
    const bottomMarginSize=cBot;
    const nearTopThreshold=cTop-contentHeight*0.2;
    const nearBotThreshold=cBot+contentHeight*0.2;
    const wordNearTop=y2>nearTopThreshold && topMarginSize>=MIN_VERT_MARGIN;
    const wordNearBot=y1<nearBotThreshold && bottomMarginSize>=MIN_VERT_MARGIN;

    let l, r, t, b;
    let side;

    if(wordNearTop){
      side="TOP";
      l=Math.max(2, x1);
      r=Math.min(PW-2, l+boxW);
      b=cTop+MARGIN_GAP;
      t=Math.min(PH-2, b+boxH);
    } else if(wordNearBot){
      side="BOTTOM";
      l=Math.max(2, x1);
      r=Math.min(PW-2, l+boxW);
      t=cBot-MARGIN_GAP;
      b=Math.max(2, t-boxH);
    } else if(wordCenter<PW/2){
      side="LEFT";
      r=mL-MARGIN_GAP;
      l=Math.max(2, r-boxW);
      if(r-l<40){ r=mL+20; l=Math.max(2, r-boxW); }
      t=y2; b=t-boxH;
    } else {
      side="RIGHT";
      l=mR+MARGIN_GAP;
      r=Math.min(PW-2, l+boxW);
      if(r-l<40){ l=mR-20; r=Math.min(PW-2, l+boxW); }
      t=y2; b=t-boxH;
    }

    /* === Resolve overlaps with previously placed text boxes === */
    if(!placedBoxes[pageNum]) placedBoxes[pageNum]=[];
    const resolved=resolveBoxOverlap(l,b,r,t,side,placedBoxes[pageNum]);
    l=resolved.l; b=resolved.b; r=resolved.r; t=resolved.t;

    /* Clamp to page bounds */
    if(b<2) { t+=(2-b); b=2; }
    if(t>PH-2) { b-=(t-(PH-2)); t=PH-2; }
    if(l<2) { r+=(2-l); l=2; }
    if(r>PW-2) { l-=(r-(PW-2)); r=PW-2; }

    /* Record this text box for future overlap checks */
    placedBoxes[pageNum].push({l,b,r,t});

    /* === Connecting line (may be diagonal after overlap shift) ===
       Line goes from text box edge midpoint to square edge midpoint. */
    let lineAnnot;
    if(side==="TOP"){
      lineAnnot=makeLineAnnot((l+r)/2, b, wordCenter, y2, p, BORDER);
    } else if(side==="BOTTOM"){
      lineAnnot=makeLineAnnot(wordCenter, y1, (l+r)/2, t, p, BORDER);
    } else if(side==="LEFT"){
      lineAnnot=makeLineAnnot(r, (b+t)/2, x1, (y1+y2)/2, p, BORDER);
    } else {
      lineAnnot=makeLineAnnot(x2, (y1+y2)/2, l, (b+t)/2, p, BORDER);
    }

    console.log("[Annomancer-FB] Match #"+idx+": ‚Üí "+side+(prismaticMode?" [prismatic]":"")+" | textBox=["+l.toFixed(1)+","+b.toFixed(1)+","+r.toFixed(1)+","+t.toFixed(1)+"]");

    const freeText=
`<<
/Type /Annot
/Subtype /FreeText
/Subj (Text Box)
/T (AutoGen)
/Rect [${l} ${b} ${r} ${t}]
/Contents (${comment})
/Page ${p}
/DA (${TEXT_C} rg /Arial 10 Tf)
/DS (font: Arial,sans-serif 10.0pt; text-align:left; color:${textHexForDS})
/C [${SNEAKY_WHITE}]
/BC [${BORDER}]
/BS << /W 2 >>
>>`;

    return square + "\n" + freeText + "\n" + lineAnnot;

  }).join("\n");
}

async function render(pdfData,matches,borderHex){
  const container=document.getElementById("pdfContainer");
  container.innerHTML="";

  const pdf=await pdfjsLib.getDocument({data:pdfData}).promise;
  const scale=1.5;

  const r=parseInt(borderHex.slice(1,3),16);
  const g=parseInt(borderHex.slice(3,5),16);
  const b=parseInt(borderHex.slice(5,7),16);

  for(let p=1;p<=pdf.numPages;p++){
    const page=await pdf.getPage(p);
    const vp=page.getViewport({scale});
    const wrap=document.createElement("div");

    const canvas=document.createElement("canvas");
    const ctx=canvas.getContext("2d");
    canvas.width=vp.width;
    canvas.height=vp.height;

    wrap.appendChild(canvas);
    container.appendChild(wrap);

    await page.render({canvasContext:ctx,viewport:vp}).promise;

    ctx.strokeStyle=`rgba(${r},${g},${b},0.9)`;
    ctx.fillStyle=`rgba(${r},${g},${b},0.25)`;
    ctx.lineWidth=2;

    matches.filter(m=>m.pageNum===p).forEach(m=>{
      const x=m.x*scale;
      const y=vp.height-(m.yTop*scale);
      const w=m.w*scale;
      const h=m.h*scale;
      ctx.fillRect(x,y,w,h);
      ctx.strokeRect(x,y,w,h);
    });
  }
}

/* Debug mode */
let debugMode = false;

document.getElementById("debugButton").onclick=()=>{
  debugMode = true;
  document.getElementById("manualFields").style.display="block";
  document.getElementById("debugRowZone").style.display="block";
  document.getElementById("pdfContainer").style.display="block";
  document.getElementById("cloudUrlSection").style.display="block";
};

/* Manual mode */
document.getElementById("searchButton").onclick=async()=>{
  const file=document.getElementById("pdfFile").files[0];
  const term=document.getElementById("searchTerm").value;
  const comment=document.getElementById("commentText").value;
  const borderHex=document.getElementById("borderPicker").value;
  const textHex=document.getElementById("textPicker").value;
  const out=document.getElementById("output");

  if(!file){ out.textContent="Select PDF."; return; }
  if(!term){ out.textContent="Enter word."; return; }

  const reader=new FileReader();
  reader.onload=async e=>{
    const data=new Uint8Array(e.target.result);
    const matches=await extractMatches(data,term);

    await render(data,matches,borderHex);

    const prismatic=document.getElementById("prismaticCheck").checked;
    const annots=generateAnnotBlocks(matches,comment,borderHex,textHex,{},prismatic,{});

    const fdf=
`%FDF-1.2
1 0 obj
<< /FDF << /Annots [
${annots}
] >> >>
endobj
trailer
<< /Root 1 0 R >>
%%EOF`;

    const blob=new Blob([fdf],{type:"application/vnd.fdf"});
    const url=URL.createObjectURL(blob);

    out.innerHTML=`Manual FDF.<br><a href="${url}" download="manual_generated.fdf">Download</a>`;
  };
  reader.readAsArrayBuffer(file);
};

/*
  === AUTOMATION ENGINE ===
*/

let cumulativeAnnots=[];
let automationRunning=false;

async function runAutomation(){
  if(automationRunning) return;

  const autoBtn=document.getElementById("autoAnnotateButton");
  const out=document.getElementById("output");
  const pdfInput=document.getElementById("pdfFile");
  const excelFile=document.getElementById("excelFile").files[0];

  const pdfFile=pdfInput.files[0];
  if(!pdfFile){ out.textContent="That didn't work. Look, I'm here to cast spells, not blame. Let's just say someone may have forgot to add a pdf."; return; }
  if(!excelFile){ out.textContent="I'm magic, but not that magic. Add a spreadsheet and try again."; return; }

  automationRunning=true;
  cumulativeAnnots=[];
  let rowNum=2;
  let skippedRows=0;
  let consecutiveEmpty=0; /* Track consecutive empty cells in column A */
  let skipShortenedClaims=false; /* Track if we should skip Shortened claims */

  autoBtn.disabled=true;
  autoBtn.style.background="#cc0000";
  autoBtn.textContent="Divining Annotations...";

  const borderHex=document.getElementById("borderPicker").value;
  const textHex=document.getElementById("textPicker").value;

  const excelArray = new Uint8Array(await excelFile.arrayBuffer());
  const wb=XLSX.read(excelArray,{type:"array"});
  const sheet=wb.Sheets[wb.SheetNames[0]];
  const rows=XLSX.utils.sheet_to_json(sheet,{header:1})||[];

  /* Check if A1 contains "Abbreviation" to enable abbreviation mode */
  const cellA1 = rows[0] && rows[0][0] ? rows[0][0].toString().trim().toLowerCase() : "";
  const abbreviationMode = cellA1 === "abbreviation";
  if (abbreviationMode) {
    out.textContent = "Abbreviation mode enabled...";
  }

  const prismaticMode=document.getElementById("prismaticCheck").checked;
  const placedBoxes={};          /* Track placed text boxes per page for overlap avoidance */
  const pageColorCounters={};    /* Track prismatic color index per page */

  const pdfArray=await pdfFile.arrayBuffer();

  while(true){
    const idx=rowNum-1;
    const row=rows[idx]||[];

    const rawTerm=row[0];
    const comment=row[2];
    const claimType=row[4] ? row[4].toString().trim().toLowerCase() : "";

    if(!rawTerm){
      consecutiveEmpty++;
      if(consecutiveEmpty>=10){
        break; /* 10 consecutive empty cells in column A ‚Üí stop */
      }
      rowNum++;
      continue;
    }

    consecutiveEmpty=0; /* Reset when non-empty cell found */

    const term = stripLineBreaks(rawTerm.toString());

    /* Handle based on column E value */
    if(claimType === "full claim"){
      /* Full claim: try to process it */
      const matches=await extractMatches(new Uint8Array(pdfArray), term, abbreviationMode);
      
      if(matches.length > 0){
        /* Full claim found in PDF - process it and skip subsequent shortened claims */
        if (debugMode) {
          await render(new Uint8Array(pdfArray), matches, borderHex);
        }
        const blocks=generateAnnotBlocks(matches, comment||"", borderHex, textHex, placedBoxes, prismaticMode, pageColorCounters);
        cumulativeAnnots.push(blocks);
        out.textContent=`Row ${rowNum} processed (Full claim found)...`;
        skipShortenedClaims = true; /* Skip subsequent shortened claims */
      } else {
        /* Full claim NOT found - allow next shortened claim as fallback */
        out.textContent=`Row ${rowNum} not found (Full claim), will try shortened...`;
        skipShortenedClaims = false; /* Allow next shortened claim */
      }
      rowNum++;
      continue;
    }
    
    if(claimType === "shortened claim"){
      if(skipShortenedClaims){
        /* We're in skip mode - skip this shortened claim */
        out.textContent=`Row ${rowNum} skipped (Shortened claim)...`;
        skippedRows++;
        rowNum++;
        continue;
      } else {
        /* Not in skip mode - process this shortened claim as fallback, then start skipping */
        const matches=await extractMatches(new Uint8Array(pdfArray), term, abbreviationMode);
        if (debugMode) {
          await render(new Uint8Array(pdfArray), matches, borderHex);
        }
        const blocks=generateAnnotBlocks(matches, comment||"", borderHex, textHex, placedBoxes, prismaticMode, pageColorCounters);
        cumulativeAnnots.push(blocks);
        out.textContent=`Row ${rowNum} processed (Shortened claim fallback)...`;
        skipShortenedClaims = true; /* Skip remaining shortened claims */
        rowNum++;
        continue;
      }
    }

    /* Empty column E - process normally and reset skip state */
    skipShortenedClaims = false; /* Reset - no longer skipping */
    
    const matches=await extractMatches(new Uint8Array(pdfArray), term, abbreviationMode);
    if (debugMode) {
      await render(new Uint8Array(pdfArray), matches, borderHex);
    }

    const blocks=generateAnnotBlocks(matches, comment||"", borderHex, textHex, placedBoxes, prismaticMode, pageColorCounters);
    cumulativeAnnots.push(blocks);

    out.textContent=`Row ${rowNum} processed...`;
    rowNum++;
  }

  if(cumulativeAnnots.length===0){
    out.textContent="No annotations accumulated." + (skippedRows > 0 ? ` (${skippedRows} shortened claims skipped)` : "");

    autoBtn.disabled=false;
    autoBtn.style.background="#0078ff";
    autoBtn.textContent="I Cast Annotate!";
    document.getElementById("rowInput").value=2;
    pdfInput.value="";
    automationRunning=false;
    return;
  }

  const finalBlocks=cumulativeAnnots.join("\n");

  let pdfName=pdfFile.name.replace(/\.pdf$/i,"");
  let finalName=pdfName + " from Annomancer.fdf";

  const fdf=
`%FDF-1.2
1 0 obj
<< /FDF << /Annots [
${finalBlocks}
] >> >>
endobj
trailer
<< /Root 1 0 R >>
%%EOF`;

  const blob=new Blob([fdf],{type:"application/vnd.fdf"});
  const url=URL.createObjectURL(blob);

  const d20Roll = Math.floor(Math.random() * 20) + 1;
  const critText = d20Roll === 20 ? " Crit!" : "";

  /* Visconti Tarot - Major Arcana from local cards folder */
  const viscontiTarot = [
    { name: "The Fool", img: "cards/The_Fool.jpg" },
    { name: "The Magician", img: "cards/The_Magician.jpg" },
    { name: "The High Priestess", img: "cards/The_High_Priestess.jpg" },
    { name: "The Empress", img: "cards/The_Empress.jpg" },
    { name: "The Emperor", img: "cards/The_Emperor.jpg" },
    { name: "The Hierophant", img: "cards/The_Hierophant.jpg" },
    { name: "The Lovers", img: "cards/The_Lovers.jpg" },
    { name: "The Chariot", img: "cards/The_Chariot.jpg" },
    { name: "Strength", img: "cards/Strength.jpg" },
    { name: "The Hermit", img: "cards/The_Hermit.jpg" },
    { name: "Wheel of Fortune", img: "cards/Wheel_of_Fortune.jpg" },
    { name: "Justice", img: "cards/Justice.jpg" },
    { name: "The Hanged Man", img: "cards/The_Hanged_Man.jpg" },
    { name: "Death", img: "cards/Death.jpg" },
    { name: "Temperance", img: "cards/Temperance.jpg" },
    { name: "The Star", img: "cards/The_Star.jpg" },
    { name: "The Moon", img: "cards/The_Moon.jpg" },
    { name: "The Sun", img: "cards/The_Sun.jpg" },
    { name: "Judgement", img: "cards/Judgement.jpg" },
    { name: "The World", img: "cards/The_World.jpg" }
  ];

  const drawnCard = viscontiTarot[Math.floor(Math.random() * viscontiTarot.length)];

  const skippedText = skippedRows > 0 ? `<br><span style="color:#666; font-size:12px;">(${skippedRows} shortened claim${skippedRows > 1 ? 's' : ''} skipped)</span>` : "";

  out.innerHTML=
    `Your annos have been 'tated. Import this onto your pdf.${skippedText}<br>
<a href="${url}" download="${finalName}">Download your annos</a><br><br>
You also rolled a ${d20Roll} on a 20-sided die${critText} and drawn the ${drawnCard.name}:<br>
<img src="${drawnCard.img}" alt="${drawnCard.name}" style="max-width:200px; margin-top:10px; border-radius:8px; box-shadow:0 2px 8px rgba(0,0,0,0.2);">`;

  autoBtn.style.background="green";
  autoBtn.textContent="Annos are 'tated!";

  setTimeout(()=>{
    cumulativeAnnots=[];
    automationRunning=false;

    autoBtn.disabled=false;
    autoBtn.style.background="#0078ff";
    autoBtn.textContent="I Cast Annotate!";

    document.getElementById("rowInput").value=2;
    pdfInput.value="";
    document.getElementById("pdfFileName").textContent="";
  },1500);
}

document.getElementById("autoAnnotateButton").onclick=runAutomation;

// Display selected file names
document.getElementById("pdfFile").onchange=function(){
  const fileName = this.files[0] ? this.files[0].name : "";
  document.getElementById("pdfFileName").textContent = fileName;
};

document.getElementById("excelFile").onchange=function(){
  const fileName = this.files[0] ? this.files[0].name : "";
  const status = document.getElementById("spreadsheetStatus");
  status.textContent = fileName ? "‚úì Selected: " + fileName : "";
  status.style.color = "#28a745";
};

// Cloud download integration
const CLOUD_URL_KEY = "annomancer_cloud_url";

// Load saved URL on startup
document.addEventListener("DOMContentLoaded", function() {
  const savedUrl = localStorage.getItem(CLOUD_URL_KEY);
  if (savedUrl) {
    document.getElementById("cloudUrl").value = savedUrl;
    document.getElementById("spreadsheetStatus").textContent = "‚òÅÔ∏è Cloud link saved. Click 'Download Latest' to get the file.";
  }
});

// Project configuration - loaded from SheetsDropdown.txt
let PROJECT_URLS = {};

// Load project configuration from external file
async function loadProjectConfig() {
  try {
    // Add cache-busting timestamp to always load fresh copy
    const response = await fetch('SheetsDropdown.txt?t=' + Date.now());
    if (!response.ok) {
      throw new Error('Could not load SheetsDropdown.txt');
    }
    const text = await response.text();
    const lines = text.trim().split('\n');
    
    const select = document.getElementById('projectSelect');
    select.innerHTML = ''; // Clear loading option
    
    PROJECT_URLS = {};
    
    lines.forEach((line, index) => {
      const colonIndex = line.indexOf(':');
      if (colonIndex > 0) {
        const name = line.substring(0, colonIndex).trim();
        const url = line.substring(colonIndex + 1).trim();
        
        if (name && url) {
          PROJECT_URLS[name] = url;
          
          const option = document.createElement('option');
          option.value = name;
          option.textContent = name;
          if (index === 0) option.selected = true;
          select.appendChild(option);
        }
      }
    });
    
    if (Object.keys(PROJECT_URLS).length === 0) {
      select.innerHTML = '<option value="">No projects configured</option>';
    }
    
  } catch (error) {
    console.error('Error loading project config:', error);
    const select = document.getElementById('projectSelect');
    select.innerHTML = '<option value="">Error loading projects</option>';
    document.getElementById('spreadsheetStatus').textContent = '‚ö†Ô∏è Could not load SheetsDropdown.txt';
    document.getElementById('spreadsheetStatus').style.color = '#cc0000';
  }
}

// Load config on page load
loadProjectConfig();

// Open Spreadsheet button - opens original URL in new tab
document.getElementById("openSpreadsheetBtn").onclick = function() {
  const projectSelect = document.getElementById("projectSelect");
  const selectedProject = projectSelect.value;
  const status = document.getElementById("spreadsheetStatus");
  
  if (!selectedProject || !PROJECT_URLS[selectedProject]) {
    status.textContent = "‚ö†Ô∏è No project selected or URL not configured";
    status.style.color = "#cc0000";
    return;
  }
  
  window.open(PROJECT_URLS[selectedProject], '_blank');
};

// Save URL when it changes (for debug mode custom URLs)
document.getElementById("cloudUrl").onchange = function() {
  const url = this.value.trim();
  if (url) {
    localStorage.setItem(CLOUD_URL_KEY, url);
    document.getElementById("spreadsheetStatus").textContent = "‚òÅÔ∏è Custom link saved!";
    document.getElementById("spreadsheetStatus").style.color = "#0078d4";
  } else {
    localStorage.removeItem(CLOUD_URL_KEY);
    document.getElementById("spreadsheetStatus").textContent = "";
  }
};

// Download Latest Spreadsheet button
document.getElementById("downloadLatestBtn").onclick = function() {
  const status = document.getElementById("spreadsheetStatus");
  const projectSelect = document.getElementById("projectSelect");
  const selectedProject = projectSelect.value;
  
  // Check for custom URL in debug mode first
  const customUrl = document.getElementById("cloudUrl").value.trim();
  let downloadUrl;
  
  if (customUrl) {
    // Use custom URL from debug field - convert to Method 4 format
    downloadUrl = convertToDownloadUrl(customUrl);
  } else {
    // Use project URL from config
    const originalUrl = PROJECT_URLS[selectedProject];
    
    if (!originalUrl) {
      status.textContent = "‚ö†Ô∏è No project selected or URL not configured";
      status.style.color = "#cc0000";
      return;
    }
    
    downloadUrl = convertToDownloadUrl(originalUrl);
  }
  
  // Create a hidden anchor and click it to trigger download
  const a = document.createElement('a');
  a.href = downloadUrl;
  a.target = '_blank';
  a.rel = 'noopener noreferrer';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  
  status.textContent = "‚¨áÔ∏è Download started! Now click 'Select Downloaded File'";
  status.style.color = "#0078d4";
};

// Select Downloaded File button
document.getElementById("selectDownloadedBtn").onclick = function() {
  document.getElementById("excelFile").click();
};

/* Convert SharePoint URL to Method 4 (UniqueId) format */
function convertToDownloadUrl(url) {
  /* If already a download.aspx URL, return as-is */
  if (url.includes('download.aspx')) {
    return url;
  }
  
  /* SharePoint formats - extract UniqueId from d= parameter */
  if (url.includes('.sharepoint.com')) {
    /* Look for d=w... parameter which contains the UniqueId */
    const dMatch = url.match(/[?&]d=w([a-f0-9]+)/i);
    if (dMatch) {
      /* Extract the hex string and format as GUID */
      const hex = dMatch[1];
      if (hex.length >= 32) {
        const guid = hex.slice(0,8) + '-' + hex.slice(8,12) + '-' + hex.slice(12,16) + '-' + hex.slice(16,20) + '-' + hex.slice(20,32);
        
        /* Extract the personal/site path */
        const pathMatch = url.match(/(\/personal\/[^\/]+)/);
        if (pathMatch) {
          const baseDomain = url.match(/(https?:\/\/[^\/]+)/)[1];
          return baseDomain + pathMatch[1] + '/_layouts/15/download.aspx?UniqueId=' + guid;
        }
      }
    }
    
    /* Fallback: add download=1 */
    const separator = url.includes('?') ? '&' : '?';
    return url + separator + 'download=1';
  }
  
  /* Egnyte formats */
  if (url.includes('.egnyte.com')) {
    if (url.includes('/fl/')) {
      return url.replace('/fl/', '/dd/');
    }
    if (url.includes('/dd/')) {
      return url;
    }
  }
  
  /* Default: return as-is */
  return url;
}

document.getElementById("stepTextButton").onclick=()=>{
  let r=parseInt(document.getElementById("rowInput").value,10);
  if(isNaN(r)||r<2) r=2;
  runStepOnce(r);
};

async function runStepOnce(r){
  const out=document.getElementById("output");
  const pdfFile=document.getElementById("pdfFile").files[0];
  const excelFile=document.getElementById("excelFile").files[0];

  if(!pdfFile){ out.textContent="Something went wrong. I won't say YOU forgot the pdf. But someone sure did."; return; }
  if(!excelFile){ out.textContent="I'm not that magical. You still gotta pick a spreadsheet."; return; }

  const borderHex=document.getElementById("borderPicker").value;
  const textHex=document.getElementById("textPicker").value;

  const excelArray = new Uint8Array(await excelFile.arrayBuffer());
  const wb=XLSX.read(excelArray,{type:"array"});
  const sheet=wb.Sheets[wb.SheetNames[0]];
  const rows=XLSX.utils.sheet_to_json(sheet,{header:1})||[];

  /* Check if A1 contains "Abbreviation" to enable abbreviation mode */
  const cellA1 = rows[0] && rows[0][0] ? rows[0][0].toString().trim().toLowerCase() : "";
  const abbreviationMode = cellA1 === "abbreviation";

  const idx=r-1;
  const row=rows[idx]||[];

  const rawTerm=row[0];
  const comment=row[2];

  if(!rawTerm){
    out.textContent="Blank encountered.";
    return;
  }

  const term = stripLineBreaks(rawTerm.toString());
  const pdfArray=await pdfFile.arrayBuffer();
  const matches=await extractMatches(new Uint8Array(pdfArray), term, abbreviationMode);
  await render(new Uint8Array(pdfArray), matches, borderHex);

  out.textContent=`Row ${r} done. Next: ${r+1}` + (abbreviationMode ? " (Abbrev mode)" : "");
  document.getElementById("rowInput").value=r+1;
}
</script>

</body>
</html>
