<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Annomancer - Greedy Sequential</title>

<script src="pdf.js"></script>
<script src="xlsx.full.min.js"></script>

<style>
  body {
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial;
    background:#f5f6fa;
    color:#222;
    text-align:center;
    padding:30px;
  }

  input, button, textarea {
    margin:10px;
    padding:10px;
    border-radius:6px;
    border:1px solid #ccc;
    font-size:16px;
  }

  button { background:#0078ff; color:#fff; cursor:pointer; border:none; }
  button:hover { background:#005fd1; }

  textarea { width:80%; max-width:800px; }

  .leftControls {
    position:absolute;
    left:80px;
    top:135px;
    display:flex;
    flex-direction:column;
    gap:15px;
    text-align:left;
  }

  #output {
    margin-top:20px;
    font-size:15px;
    text-align:left;
    display:inline-block;
    width:85%;
    background:#fff;
    border-radius:8px;
    padding:12px;
    box-shadow:0 2px 6px rgba(0,0,0,0.1);
    white-space:pre-wrap;
  }

  #debugRowZone {
    display:none;
    position:absolute;
    right:60px;
    top:260px;
    text-align:right;
  }

  #pdfContainer { margin-top:170px; display:none; }

  canvas {
    border:1px solid #ccc;
    box-shadow:0 0 5px rgba(0,0,0,0.2);
    display:block;
  }

  #debugButton {
    background:#ccc !important;
    color:#000 !important;
    padding:10px 16px;
    border-radius:6px;
    border:1px solid #aaa;
  }

  #debugButton:hover { background:#b5b5b5 !important; }

  #manualFields { display:none; }

  #autoAnnotateButton {
    margin-top:20px;
    margin-bottom:10px;
  }

  #passwordSection {
    margin: 20px auto;
    padding: 30px;
    background: #fff;
    border-radius: 8px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    max-width: 400px;
  }

  #passwordSection input[type="password"] {
    width: 200px;
  }

  #passwordError {
    color: #cc0000;
    margin-top: 10px;
    display: none;
  }

  .protected-content {
    display: none;
  }

  .custom-file-input {
    display: inline-block;
  }

  .custom-file-input input[type="file"] {
    display: none;
  }

  .custom-file-input label {
    display: inline-block;
    padding: 10px 16px;
    background: #0078ff;
    color: #fff;
    border-radius: 6px;
    cursor: pointer;
    font-size: 16px;
    margin: 10px;
  }

  .custom-file-input label:hover {
    background: #005fd1;
  }

  .file-name {
    margin-left: 10px;
    font-style: italic;
    color: #666;
  }
</style>
</head>

<body>

<h1>Annomancer</h1>
<p>A little science. A little magic. A roll of the dice. Boom. You've got annos.</p>

<div id="passwordSection">
  <h3>üîê Enter Password to Continue</h3>
  <input type="password" id="passwordInput" placeholder="Enter password">
  <button id="passwordSubmit">Submit</button>
  <p id="passwordError">Incorrect password. Try again.</p>
</div>

<div id="protectedContent" class="protected-content">
<div class="leftControls">
  <label><b>Border Color:</b></label>
  <input type="color" id="borderPicker" value="#FF0000">

  <label><b>Text Box Color:</b></label>
  <input type="color" id="textPicker" value="#FF0001">
</div>

<div style="position:relative; width:85%; margin:auto; margin-top:10px;">
  <div style="text-align:center;">
    <div class="custom-file-input">
      <label for="pdfFile">Select your pdf</label>
      <input type="file" id="pdfFile" accept="application/pdf" />
      <span id="pdfFileName" class="file-name"></span>
    </div>
  </div>
  <button id="debugButton" style="position:absolute; right:0; top:0;">Debug mode</button>
</div>

<br>

<div class="custom-file-input">
  <label for="excelFile">Select your anno spreadsheet</label>
  <input type="file" id="excelFile" accept=".xlsx">
  <span id="excelFileName" class="file-name"></span>
</div><br>

<button id="autoAnnotateButton">I Cast Annotate!</button><br>

<div id="debugRowZone">
  <input type="number" id="rowInput" value="2" min="2" max="100" style="width:60px;">
  <button id="stepTextButton">Step text</button>
</div>

<div id="output"></div>

<div id="manualFields">
  <input type="text" id="searchTerm" placeholder="Enter word or phrase"><br>
  <textarea id="commentText" rows="3" cols="60">This is comment box text.</textarea><br>
  <button id="searchButton">Search & Show</button>
</div>

<div id="pdfContainer"></div>
</div>

<script>
/* == Password Protection == */
const CORRECT_PASSWORD = "hellfireclub";
const AUTH_COOKIE_NAME = "annomancer_auth";

function setCookie(name, value, days) {
  const expires = new Date(Date.now() + days * 864e5).toUTCString();
  document.cookie = name + "=" + encodeURIComponent(value) + "; expires=" + expires + "; path=/";
}

function getCookie(name) {
  return document.cookie.split("; ").reduce((r, v) => {
    const parts = v.split("=");
    return parts[0] === name ? decodeURIComponent(parts[1]) : r;
  }, "");
}

function checkAuth() {
  return getCookie(AUTH_COOKIE_NAME) === "authenticated";
}

function showProtectedContent() {
  document.getElementById("passwordSection").style.display = "none";
  document.getElementById("protectedContent").style.display = "block";
}

function handlePasswordSubmit() {
  const input = document.getElementById("passwordInput");
  const error = document.getElementById("passwordError");
  
  if (input.value === CORRECT_PASSWORD) {
    setCookie(AUTH_COOKIE_NAME, "authenticated", 365);
    showProtectedContent();
  } else {
    error.style.display = "block";
    input.value = "";
    input.focus();
  }
}

// Check authentication on page load
document.addEventListener("DOMContentLoaded", function() {
  if (checkAuth()) {
    showProtectedContent();
  }
  
  document.getElementById("passwordSubmit").addEventListener("click", handlePasswordSubmit);
  document.getElementById("passwordInput").addEventListener("keypress", function(e) {
    if (e.key === "Enter") {
      handlePasswordSubmit();
    }
  });
});

/* == PDF.js worker == */
pdfjsLib.GlobalWorkerOptions.workerSrc = "pdf.worker.js";

const SNEAKY_WHITE="1.0 1.0 0.988235";
const LEFT_PAD=3, RIGHT_PAD=3, DESC=0.22, TOPOS=0.02;

const measureCanvas=document.createElement('canvas');
const mctx=measureCanvas.getContext('2d');
function setFont(px,fam){ mctx.font=px+"px "+(fam||"sans-serif"); }
function measure(t){ return mctx.measureText(t).width||0; }

/* ================================================
   GREEDY SEQUENTIAL SEARCH ENGINE
   Supports up to 400 words with up to 10 line breaks
   Position-aware: segments must be sequential in PDF
   ================================================ */
async function extractMatches(pdfData, term){
  const pdf = await pdfjsLib.getDocument({data: pdfData}).promise;
  const out = [];
  const search = term.trim();
  if (!search) return out;

  const MAX_SEGMENTS = 11; /* 10 line breaks = 11 segments max */

  /* process each page */
  for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
    const page = await pdf.getPage(pageNum);
    const text = await page.getTextContent();
    let chars = [];

    /* flatten char runs */
    for (const item of text.items) {
      const str = item.str || "";
      const T = item.transform;
      for (let i = 0; i < str.length; i++) {
        chars.push({ ch: str[i], T, item, offset: i });
      }
    }
    if (!chars.length) continue;

    const merged = chars.map(c => c.ch).join("");
    const mergedLower = merged.toLowerCase();

    /* literal block finder - returns box AND end position in merged text */
    function findLiteralBox(needle, startFrom = 0) {
      if (!needle) return null;
      const nl = needle.toLowerCase();

      let pos = mergedLower.indexOf(nl, startFrom);
      if (pos === -1) return null;

      let end = pos + needle.length - 1;
      if (end >= chars.length) return null;

      let minLeft = Infinity, maxRight = -Infinity;
      let minBot = Infinity, maxTop = -Infinity;

      for (let c = pos; c <= end; c++) {
        const ch = chars[c];
        const T = ch.T;
        const item = ch.item;

        const runW = item.width || 0;
        const runLen = item.str.length || 1;
        const charW = runW / runLen;

        const h = Math.hypot(T[2], T[3]) || Math.abs(T[3]) || 10;
        const yTop = T[5] + h * (1 + TOPOS);
        const yBot = T[5] - h * DESC;

        const left = T[4] + charW * ch.offset;
        const right = left + charW;

        if (left < minLeft) minLeft = left;
        if (right > maxRight) maxRight = right;
        if (yTop > maxTop) maxTop = yTop;
        if (yBot < minBot) minBot = yBot;
      }

      minLeft -= LEFT_PAD;
      maxRight += RIGHT_PAD;

      return {
        box: {
          pageNum,
          x: minLeft,
          yTop: maxTop,
          yBottom: minBot,
          w: maxRight - minLeft,
          h: maxTop - minBot
        },
        endPos: end + 1 /* position to start next search from */
      };
    }

    /* Check if boxes are within reasonable proximity of each other */
    function boxesAreProximate(boxes) {
      if (boxes.length <= 1) return true;
      
      /* Calculate average box height as baseline */
      let totalHeight = 0;
      for (const b of boxes) {
        totalHeight += b.h;
      }
      const avgHeight = totalHeight / boxes.length;
      const maxAllowedGap = avgHeight * 15; /* Allow up to ~15 lines of separation */
      
      /* Sort boxes by vertical position (top to bottom) */
      const sorted = [...boxes].sort((a, b) => b.yTop - a.yTop);
      
      /* Check gap between each consecutive pair */
      for (let i = 0; i < sorted.length - 1; i++) {
        const upper = sorted[i];
        const lower = sorted[i + 1];
        const gap = upper.yBottom - lower.yTop;
        
        /* If gap is positive and too large, boxes are too far apart */
        if (gap > maxAllowedGap) {
          return false;
        }
      }
      return true;
    }

    /* Greedy sequential: find longest match from current position, then continue */
    function findGreedySegments(searchText) {
      const segments = [];
      const words = searchText.split(/\s+/);
      let wordIndex = 0;
      let searchPos = 0; /* Position in merged PDF text - ensures sequential matches */

      while (wordIndex < words.length && segments.length < MAX_SEGMENTS) {
        let found = false;

        /* Try from all remaining words down to single word */
        for (let endIdx = words.length; endIdx > wordIndex; endIdx--) {
          const candidate = words.slice(wordIndex, endIdx).join(" ");
          const result = findLiteralBox(candidate, searchPos);

          if (result) {
            segments.push(result.box);
            searchPos = result.endPos; /* Next search starts after this match */
            wordIndex = endIdx; /* Move past matched words */
            found = true;
            break;
          }
        }

        /* If even a single word isn't found at this position, fail completely */
        if (!found) {
          return []; /* Return empty - require complete match */
        }
      }

      /* Only return segments if ALL words were matched */
      if (wordIndex < words.length) {
        return []; /* Incomplete match */
      }

      return segments;
    }

    /* Try literal match first - best case */
    const literalResult = findLiteralBox(search, 0);
    if (literalResult) {
      out.push(literalResult.box);
      continue;
    }

    /* Use greedy sequential matching */
    const segments = findGreedySegments(search);

    /* Skip if no complete match found */
    if (segments.length === 0) continue;

    /* Proximity check: reject if boxes are too far apart */
    if (!boxesAreProximate(segments)) continue;

    /* Merge all segment boxes into one */
    let minLeft = Infinity, maxRight = -Infinity;
    let minBot = Infinity, maxTop = -Infinity;

    for (const b of segments) {
      if (b.x < minLeft) minLeft = b.x;
      if (b.x + b.w > maxRight) maxRight = b.x + b.w;
      if (b.yBottom < minBot) minBot = b.yBottom;
      if (b.yTop > maxTop) maxTop = b.yTop;
    }

    out.push({
      pageNum,
      x: minLeft,
      yTop: maxTop,
      yBottom: minBot,
      w: maxRight - minLeft,
      h: maxTop - minBot
    });
  }

  return out;
}

/* everything below this point stays exactly the same */

function esc(s){ 
  return s
    .replace(/\\/g,"\\\\")
    .replace(/\(/g,"\\(")
    .replace(/\)/g,"\\)")
    .replace(/[\r\n]+/g," ")      // Replace line breaks with space
    .replace(/[""]/g,'"')          // Smart quotes ‚Üí straight quotes
    .replace(/['']/g,"'")          // Smart apostrophes ‚Üí straight
    .replace(/[‚Äî‚Äì]/g,"-")          // Em/en dash ‚Üí hyphen
    .replace(/‚Ä¶/g,"...")           // Ellipsis ‚Üí three dots
    .replace(/[^\x00-\x7F]/g,"");  // Remove any remaining non-ASCII
}

function hexToRgbFloats(hex){
  hex=hex.replace("#","");
  const r=parseInt(hex.slice(0,2),16)/255;
  const g=parseInt(hex.slice(2,4),16)/255;
  const b=parseInt(hex.slice(4,6),16)/255;
  return `${r} ${g} ${b}`;
}

function generateAnnotBlocks(matches, commentText, borderHex, textHex){
  const comment=esc((commentText||"").trim());
  const EXP=1.5, GAP=0.5, CH=55;
  const BORDER=hexToRgbFloats(borderHex);
  const TEXT=hexToRgbFloats(textHex);

  return matches.map(m=>{
    const x1=m.x, y1=m.yBottom, x2=m.x+m.w, y2=m.yTop;
    const p=m.pageNum-1;

    let square=
`<<
/Type /Annot
/Subtype /Square
/Rect [${x1} ${y1} ${x2} ${y2}]
/T (AutoGen)
/Contents ()
/Page ${p}
/C [${BORDER}]
/BS << /W 2 >>
/Border [0 0 2]
>>`;

    if(!comment) return square;

    const cw=m.w*EXP;
    const l=x1, r=l+cw;
    const t=y1-GAP;
    const b=t-CH;

    const freeText=
`<<
/Type /Annot
/Subtype /FreeText
/Subj (Text Box)
/T (AutoGen)
/Rect [${l} ${b} ${r} ${t}]
/Contents (${comment})
/Page ${p}
/DA (${TEXT} rg /Arial 10 Tf)
/DS (font: Arial,sans-serif 10.0pt; text-align:left; color:${textHex})
/C [${SNEAKY_WHITE}]
/BC [${BORDER}]
/BS << /W 2 >>
>>`;

    return square + "\n" + freeText;

  }).join("\n");
}

async function render(pdfData,matches,borderHex){
  const container=document.getElementById("pdfContainer");
  container.innerHTML="";

  const pdf=await pdfjsLib.getDocument({data:pdfData}).promise;
  const scale=1.5;

  const r=parseInt(borderHex.slice(1,3),16);
  const g=parseInt(borderHex.slice(3,5),16);
  const b=parseInt(borderHex.slice(5,7),16);

  for(let p=1;p<=pdf.numPages;p++){
    const page=await pdf.getPage(p);
    const vp=page.getViewport({scale});
    const wrap=document.createElement("div");

    const canvas=document.createElement("canvas");
    const ctx=canvas.getContext("2d");
    canvas.width=vp.width;
    canvas.height=vp.height;

    wrap.appendChild(canvas);
    container.appendChild(wrap);

    await page.render({canvasContext:ctx,viewport:vp}).promise;

    ctx.strokeStyle=`rgba(${r},${g},${b},0.9)`;
    ctx.fillStyle=`rgba(${r},${g},${b},0.25)`;
    ctx.lineWidth=2;

    matches.filter(m=>m.pageNum===p).forEach(m=>{
      const x=m.x*scale;
      const y=vp.height-(m.yTop*scale);
      const w=m.w*scale;
      const h=m.h*scale;
      ctx.fillRect(x,y,w,h);
      ctx.strokeRect(x,y,w,h);
    });
  }
}

/* Debug mode */
let debugMode = false;

document.getElementById("debugButton").onclick=()=>{
  debugMode = true;
  document.getElementById("manualFields").style.display="block";
  document.getElementById("debugRowZone").style.display="block";
  document.getElementById("pdfContainer").style.display="block";
};

/* Manual mode */
document.getElementById("searchButton").onclick=async()=>{
  const file=document.getElementById("pdfFile").files[0];
  const term=document.getElementById("searchTerm").value;
  const comment=document.getElementById("commentText").value;
  const borderHex=document.getElementById("borderPicker").value;
  const textHex=document.getElementById("textPicker").value;
  const out=document.getElementById("output");

  if(!file){ out.textContent="Select PDF."; return; }
  if(!term){ out.textContent="Enter word."; return; }

  const reader=new FileReader();
  reader.onload=async e=>{
    const data=new Uint8Array(e.target.result);
    const matches=await extractMatches(data,term);

    await render(data,matches,borderHex);

    const annots=generateAnnotBlocks(matches,comment,borderHex,textHex);

    const fdf=
`%FDF-1.2
1 0 obj
<< /FDF << /Annots [
${annots}
] >> >>
endobj
trailer
<< /Root 1 0 R >>
%%EOF`;

    const blob=new Blob([fdf],{type:"application/vnd.fdf"});
    const url=URL.createObjectURL(blob);

    out.innerHTML=`Manual FDF.<br><a href="${url}" download="manual_generated.fdf">Download</a>`;
  };
  reader.readAsArrayBuffer(file);
};

/*
  === AUTOMATION ENGINE (UNCHANGED) ===
*/

let cumulativeAnnots=[];
let automationRunning=false;

async function runAutomation(){
  if(automationRunning) return;

  const autoBtn=document.getElementById("autoAnnotateButton");
  const out=document.getElementById("output");
  const pdfInput=document.getElementById("pdfFile");
  const excelFile=document.getElementById("excelFile").files[0];

  const pdfFile=pdfInput.files[0];
  if(!pdfFile){ out.textContent="That didn't work. Look, I'm here to cast spells, not blame. Let's just stay someone may have forgot to add a pdf."; return; }
  if(!excelFile){ out.textContent="I'm magic, but not that magic. Add a spreadsheet and try again."; return; }

  automationRunning=true;
  cumulativeAnnots=[];
  let rowNum=2;

  autoBtn.disabled=true;
  autoBtn.style.background="#cc0000";
  autoBtn.textContent="Divining Annotations...";

  const borderHex=document.getElementById("borderPicker").value;
  const textHex=document.getElementById("textPicker").value;

  const excelArray=await excelFile.arrayBuffer();
  const wb=XLSX.read(new Uint8Array(excelArray),{type:"array"});
  const sheet=wb.Sheets[wb.SheetNames[0]];
  const rows=XLSX.utils.sheet_to_json(sheet,{header:1})||[];

  const pdfArray=await pdfFile.arrayBuffer();

  while(true){
    const idx=rowNum-1;
    const row=rows[idx]||[];

    const term=row[0];
    const comment=row[2];

    if(!term){
      break;
    }

    const matches=await extractMatches(new Uint8Array(pdfArray), term.toString());
    if (debugMode) {
      await render(new Uint8Array(pdfArray), matches, borderHex);
    }

    const blocks=generateAnnotBlocks(matches, comment||"", borderHex, textHex);
    cumulativeAnnots.push(blocks);

    out.textContent=`Row ${rowNum} processed...`;
    rowNum++;
  }

  if(cumulativeAnnots.length===0){
    out.textContent="No annotations accumulated.";

    autoBtn.disabled=false;
    autoBtn.style.background="#0078ff";
    autoBtn.textContent="I Cast Annotate!";
    document.getElementById("rowInput").value=2;
    pdfInput.value="";
    automationRunning=false;
    return;
  }

  const finalBlocks=cumulativeAnnots.join("\n");

  let pdfName=pdfFile.name.replace(/\.pdf$/i,"");
  let finalName=pdfName + " from Annomancer.fdf";

  const fdf=
`%FDF-1.2
1 0 obj
<< /FDF << /Annots [
${finalBlocks}
] >> >>
endobj
trailer
<< /Root 1 0 R >>
%%EOF`;

  const blob=new Blob([fdf],{type:"application/vnd.fdf"});
  const url=URL.createObjectURL(blob);

  const d20Roll = Math.floor(Math.random() * 20) + 1;
  const critText = d20Roll === 20 ? " Crit!" : "";

  /* Visconti Tarot - Major Arcana */
  const viscontiTarot = [
    { name: "The Fool", img: "https://upload.wikimedia.org/wikipedia/commons/thumb/9/90/Visconti-Sforza_tarot_deck._The_Fool.jpg/170px-Visconti-Sforza_tarot_deck._The_Fool.jpg" },
    { name: "The Magician", img: "https://upload.wikimedia.org/wikipedia/commons/thumb/6/6d/Visconti-Sforza_tarot_deck._The_Magician.jpg/170px-Visconti-Sforza_tarot_deck._The_Magician.jpg" },
    { name: "The High Priestess", img: "https://upload.wikimedia.org/wikipedia/commons/thumb/1/1a/Visconti-Sforza_tarot_deck._The_High_Priestess.jpg/170px-Visconti-Sforza_tarot_deck._The_High_Priestess.jpg" },
    { name: "The Empress", img: "https://upload.wikimedia.org/wikipedia/commons/thumb/c/c9/Visconti-Sforza_tarot_deck._The_Empress.jpg/170px-Visconti-Sforza_tarot_deck._The_Empress.jpg" },
    { name: "The Emperor", img: "https://upload.wikimedia.org/wikipedia/commons/thumb/8/85/Visconti-Sforza_tarot_deck._The_Emperor.jpg/170px-Visconti-Sforza_tarot_deck._The_Emperor.jpg" },
    { name: "The Hierophant", img: "https://upload.wikimedia.org/wikipedia/commons/thumb/f/fb/Visconti-Sforza_tarot_deck._The_Pope.jpg/170px-Visconti-Sforza_tarot_deck._The_Pope.jpg" },
    { name: "The Lovers", img: "https://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Visconti-Sforza_tarot_deck._Love.jpg/170px-Visconti-Sforza_tarot_deck._Love.jpg" },
    { name: "The Chariot", img: "https://upload.wikimedia.org/wikipedia/commons/thumb/4/40/Visconti-Sforza_tarot_deck._The_Chariot.jpg/170px-Visconti-Sforza_tarot_deck._The_Chariot.jpg" },
    { name: "Strength", img: "https://upload.wikimedia.org/wikipedia/commons/thumb/6/6a/Visconti-Sforza_tarot_deck._Fortitude.jpg/170px-Visconti-Sforza_tarot_deck._Fortitude.jpg" },
    { name: "The Hermit", img: "https://upload.wikimedia.org/wikipedia/commons/thumb/b/b5/Visconti-Sforza_tarot_deck._The_Hermit.jpg/170px-Visconti-Sforza_tarot_deck._The_Hermit.jpg" },
    { name: "Wheel of Fortune", img: "https://upload.wikimedia.org/wikipedia/commons/thumb/6/6a/Visconti-Sforza_tarot_deck._Wheel_of_Fortune.jpg/170px-Visconti-Sforza_tarot_deck._Wheel_of_Fortune.jpg" },
    { name: "Justice", img: "https://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Visconti-Sforza_tarot_deck._Justice.jpg/170px-Visconti-Sforza_tarot_deck._Justice.jpg" },
    { name: "The Hanged Man", img: "https://upload.wikimedia.org/wikipedia/commons/thumb/4/46/Visconti-Sforza_tarot_deck._The_Hanged_Man.jpg/170px-Visconti-Sforza_tarot_deck._The_Hanged_Man.jpg" },
    { name: "Death", img: "https://upload.wikimedia.org/wikipedia/commons/thumb/2/2a/Visconti-Sforza_tarot_deck._Death.jpg/170px-Visconti-Sforza_tarot_deck._Death.jpg" },
    { name: "Temperance", img: "https://upload.wikimedia.org/wikipedia/commons/thumb/0/0d/Visconti-Sforza_tarot_deck._Temperance.jpg/170px-Visconti-Sforza_tarot_deck._Temperance.jpg" },
    { name: "The Star", img: "https://upload.wikimedia.org/wikipedia/commons/thumb/1/1b/Visconti-Sforza_tarot_deck._The_Star.jpg/170px-Visconti-Sforza_tarot_deck._The_Star.jpg" },
    { name: "The Moon", img: "https://upload.wikimedia.org/wikipedia/commons/thumb/e/e2/Visconti-Sforza_tarot_deck._The_Moon.jpg/170px-Visconti-Sforza_tarot_deck._The_Moon.jpg" },
    { name: "The Sun", img: "https://upload.wikimedia.org/wikipedia/commons/thumb/4/forty/Visconti-Sforza_tarot_deck._The_Sun.jpg/170px-Visconti-Sforza_tarot_deck._The_Sun.jpg" },
    { name: "Judgement", img: "https://upload.wikimedia.org/wikipedia/commons/thumb/f/f4/Visconti-Sforza_tarot_deck._The_Last_Judgement.jpg/170px-Visconti-Sforza_tarot_deck._The_Last_Judgement.jpg" },
    { name: "The World", img: "https://upload.wikimedia.org/wikipedia/commons/thumb/c/c5/Visconti-Sforza_tarot_deck._The_World.jpg/170px-Visconti-Sforza_tarot_deck._The_World.jpg" }
  ];

  const drawnCard = viscontiTarot[Math.floor(Math.random() * viscontiTarot.length)];

  out.innerHTML=
    `Your annos have been 'tated. Import this onto your pdf.<br>
<a href="${url}" download="${finalName}">Download your annos</a><br><br>
You also rolled a ${d20Roll} on a 20-sided die.${critText}<br><br>
You have drawn the ${drawnCard.name}:<br>
<img src="${drawnCard.img}" alt="${drawnCard.name}" style="max-width:200px; margin-top:10px; border-radius:8px; box-shadow:0 2px 8px rgba(0,0,0,0.2);">`;

  autoBtn.style.background="green";
  autoBtn.textContent="Annos are 'tated!";

  setTimeout(()=>{
    cumulativeAnnots=[];
    automationRunning=false;

    autoBtn.disabled=false;
    autoBtn.style.background="#0078ff";
    autoBtn.textContent="I Cast Annotate!";

    document.getElementById("rowInput").value=2;
    pdfInput.value="";
    document.getElementById("pdfFileName").textContent="";
  },1500);
}

document.getElementById("autoAnnotateButton").onclick=runAutomation;

// Display selected file names
document.getElementById("pdfFile").onchange=function(){
  const fileName = this.files[0] ? this.files[0].name : "";
  document.getElementById("pdfFileName").textContent = fileName;
};

document.getElementById("excelFile").onchange=function(){
  const fileName = this.files[0] ? this.files[0].name : "";
  document.getElementById("excelFileName").textContent = fileName;
};

document.getElementById("stepTextButton").onclick=()=>{
  let r=parseInt(document.getElementById("rowInput").value,10);
  if(isNaN(r)||r<2) r=2;
  runStepOnce(r);
};

async function runStepOnce(r){
  const out=document.getElementById("output");
  const pdfFile=document.getElementById("pdfFile").files[0];
  const excelFile=document.getElementById("excelFile").files[0];

  if(!pdfFile){ out.textContent="Something went wrong. I won't say YOU forgot the pdf. But someone sure did."; return; }
  if(!excelFile){ out.textContent="I'm not that magical. You still gotta pick a spreadsheet."; return; }

  const borderHex=document.getElementById("borderPicker").value;
  const textHex=document.getElementById("textPicker").value;

  const excelArray=await excelFile.arrayBuffer();
  const wb=XLSX.read(new Uint8Array(excelArray),{type:"array"});
  const sheet=wb.Sheets[wb.SheetNames[0]];
  const rows=XLSX.utils.sheet_to_json(sheet,{header:1})||[];

  const idx=r-1;
  const row=rows[idx]||[];

  const term=row[0];
  const comment=row[2];

  if(!term){
    out.textContent="Blank encountered.";
    return;
  }

  const pdfArray=await pdfFile.arrayBuffer();
  const matches=await extractMatches(new Uint8Array(pdfArray), term.toString());
  await render(new Uint8Array(pdfArray), matches, borderHex);

  out.textContent=`Row ${r} done. Next: ${r+1}`;
  document.getElementById("rowInput").value=r+1;
}
</script>

</body>
</html>
